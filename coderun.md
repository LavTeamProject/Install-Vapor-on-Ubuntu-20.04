# Оглавление
- [4. Ход конём](#4-ход-конём)
- [12. Длина кратчайшего пути](#12-длина-кратчайшего-пути)
- [14. Блохи](#14-блохи)
- [15. Путь спелеолога](#15-путь-спелеолога)
- [28. НВП с восстановлением ответа](#28-нвп-с-восстановлением-ответа)
- [33. Расстояние по Левенштейну](#33-расстояние-по-левенштейну)
- [34. Космический мусорщик](#34-космический-мусорщик)
- [39. Откуда достижима первая вершина](#39-откуда-достижима-первая-вершина)
- [43. Два коня](#43-два-коня)
- [44. Числа](#44-числа)
- [51. Номер появления слова](#51-номер-появления-слова)
- [52. Словарь синонимов](#52-словарь-синонимов)
- [54. Полиглоты](#54-полиглоты)
- [55. Злые свинки](#55-злые-свинки)
- [57. Инопланетный геном](#57-инопланетный-геном)
- [58. OpenCalculator](#58-opencalculator)
- [60. Кубики](#60-кубики)
- [61. Пересечение множеств](#61-пересечение-множеств)
- [62. Количество различных чисел](#62-количество-различных-чисел)
- [64. Сапёр](#64-сапёр)
- [69. Больше своих соседей](#69-больше-своих-соседей)
- [70. Ближайшее число](#70-ближайшее-число)
- [71. Определить вид последовательности](#71-определить-вид-последовательности)
- [72. Возрастает ли список?](#72-возрастает-ли-список)
- [74. Узник замка Иф](#74-узник-замка-иф)
- [75. Метро](#75-метро)
- [80. Телефонные номера](#80-телефонные-номера)
- [81. Треугольник](#81-треугольник)
- [82. Кондиционер](#82-кондиционер)
- [83. Клавиатура](#83-клавиатура)
- [84. Пирамида](#84-пирамида)
- [86. Банковские счета](#86-банковские-счета)
- [88. Контрольная по ударениям](#88-контрольная-по-ударениям)
- [91. Сумма номеров](#91-сумма-номеров)
- [93. Город Че](#93-город-че)
- [96. Подстрока](#96-подстрока)
- [99. Двоичный поиск](#99-двоичный-поиск)
- [100. Приближенный двоичный поиск](#100-приближенный-двоичный-поиск)
- [101. Дипломы](#101-дипломы)
- [103. Расстановка ноутбуков](#103-расстановка-ноутбуков)
- [106. Провода](#106-провода)
- [108. Медиана объединения](#108-медиана-объединения)
- [114. Кассы](#114-кассы)
- [120. Высота дерева](#120-высота-дерева)
- [121. Глубина добавляемых элементов](#121-глубина-добавляемых-элементов)
- [124. Вывод листьев](#124-вывод-листьев)
- [125. Вывод развилок](#125-вывод-развилок)
- [126. Вывод веток](#126-вывод-веток)
- [127. АВЛ-сбалансированность](#127-авл-сбалансированность)
- [129. Родословная: подсчет уровней](#129-родословная-подсчет-уровней)
- [130. Гистограмма](#130-гистограмма)
- [132. Коллекционер Диего](#132-коллекционер-диего)
- [134. Хорошая строка](#134-хорошая-строка)
- [135. Операционные системы lite](#135-операционные-системы-lite)
- [137. Минимальный прямоугольник](#137-минимальный-прямоугольник)
- [138. Сумма в прямоугольнике](#138-сумма-в-прямоугольнике)
- [139. Скучная лекция](#139-скучная-лекция)
- [140. Стек с защитой от ошибок](#140-стек-с-защитой-от-ошибок)
- [141. Правильная скобочная последовательность](#141-правильная-скобочная-последовательность)
- [142. Постфиксная запись](#142-постфиксная-запись)
- [143. Сортировка вагонов lite](#143-сортировка-вагонов-lite)
- [144. Великое Лайнландское переселение](#144-великое-лайнландское-переселение)
- [145. Очередь с защитой от ошибок](#145-очередь-с-защитой-от-ошибок)
- [146. Игра в пьяницу](#146-игра-в-пьяницу)
- [147. Дек с защитой от ошибок](#147-дек-с-защитой-от-ошибок)
- [148. Хипуй](#148-хипуй)
- [149. Пирамидальная сортировка](#149-пирамидальная-сортировка)
- [150. Три единицы подряд](#150-три-единицы-подряд)
- [151. Кузнечик](#151-кузнечик)
- [175. Уникальные пользователи](#175-уникальные-пользователи)
- [220. Нормализация показателей](#220-нормализация-показателей)
- [272. Простая подсказка](#272-простая-подсказка)
- [290. Игра](#290-игра)
- [294. Сумма различных](#294-сумма-различных)
- [302. Восстановить матрицу](#302-восстановить-матрицу)
- [304. Проверка палиндрома](#304-проверка-палиндрома)
- [310. Кодирование длин серий](#310-кодирование-длин-серий)
- [374. Оценка](#374-оценка)
- [405. Тетрамино](#405-тетрамино)
- [410. Сложить и вычесть](#410-сложить-и-вычесть)
- [455. Села батарейка](#455-села-батарейка)
- [456. Запускайте гуся](#456-запускайте-гуся)
- [458. Восстановление отчётов](#458-восстановление-отчётов)
- [467. Суеверный коллекционер](#467-суеверный-коллекционер)
- [469. Игра в города](#469-игра-в-города)
- [470. Чёрное и белое](#470-чёрное-и-белое)
- [471. Журнал без дат](#471-журнал-без-дат)
- [475. Баг в БД](#475-баг-в-бд)
- [476. Градиент](#476-градиент)
- [478. Сокращение маршрута](#478-сокращение-маршрута)
- [543. Классы подобия треугольников](#543-классы-подобия-треугольников)
- [4728. Крош, Ежик и квадратичная игра](#4728-крош-ежик-и-квадратичная-игра)
- [4729. Крош и строка](#4729-крош-и-строка)
- [5202. Юля, Никита и задачи](#5202-юля-никита-и-задачи)
- [5204. Умножай и транспонируй!](#5204-умножай-и-транспонируй)
- [5205. Ещё одна задача на теорию чисел](#5205-ещё-одна-задача-на-теорию-чисел)
- [5206. Выставление тегов](#5206-выставление-тегов)
- [5316. Снежки](#5316-снежки)
- [5317. В город на ярмарку](#5317-в-город-на-ярмарку)
- [5321. Наряжаем ёлку](#5321-наряжаем-ёлку)

---



### 4. [Ход конём](https://coderun.yandex.ru/problem/knight-move)
  
**Условие задачи:**
Дана прямоугольная доска N×M (N строк и M столбцов). В левом верхнем углу находится шахматный конь, которого необходимо переместить в правый нижний угол доски. В данной задаче конь может перемещаться на две клетки вниз и одну клетку вправо или на одну клетку вниз и две клетки вправо. Необходимо определить, сколько существует различных маршрутов, ведущих из левого верхнего в правый нижний угол.

**Решение задачи:**

```swift
import Foundation

// Считываем размеры доски N и M
let input = readLine()!.split(separator: " ").map { Int($0)! }
let n = input[0] // Количество строк
let m = input[1] // Количество столбцов

// Создаем двумерный массив для хранения количества способов добраться до каждой клетки
// dp[i][j] будет содержать количество маршрейсов до клетки (i, j)
var dp = Array(repeating: Array(repeating: 0, count: m + 1), count: n + 1)

// Начальная позиция: левый верхний угол (1, 1)
dp[1][1] = 1

// Проходим по всем клеткам доски
for i in 1...n {
    for j in 1...m {
        // Если в текущую клетку можно попасть, обновляем возможные следующие позиции
        if dp[i][j] > 0 {
            // Ход 1: две клетки вниз и одну вправо
            let nextRow1 = i + 2
            let nextCol1 = j + 1
            if nextRow1 <= n && nextCol1 <= m {
                dp[nextRow1][nextCol1] += dp[i][j]
            }
            
            // Ход 2: одну клетку вниз и две вправо
            let nextRow2 = i + 1
            let nextCol2 = j + 2
            if nextRow2 <= n && nextCol2 <= m {
                dp[nextRow2][nextCol2] += dp[i][j]
            }
        }
    }
}

// Выводим количество способов добраться до правого нижнего угла (n, m)
print(dp[n][m])
```

---
### 12. [Длина кратчайшего пути](https://coderun.yandex.ru/problem/shortest-path-length)
  
**Условие задачи:**
Дан неориентированный граф. Найдите длину минимального пути между двумя вершинами.

**Решение задачи:**

```swift
import Foundation

// Считываем количество вершин
let n = Int(readLine()!)!

// Считываем матрицу смежности
var graph: [[Bool]] = []
for _ in 0..<n {
    let row = readLine()!.split(separator: " ").map { Int($0)! == 1 }
    graph.append(row)
}

// Считываем начальную и конечную вершины
let vertices = readLine()!.split(separator: " ").map { Int($0)! - 1 } // Переводим в 0-индексацию
let start = vertices[0]
let end = vertices[1]

// Реализуем BFS для поиска кратчайшего пути
var queue: [Int] = [start]
var distances: [Int] = Array(repeating: -1, count: n)
distances[start] = 0

while !queue.isEmpty {
    let current = queue.removeFirst()
    
    // Если дошли до конечной вершины, выходим
    if current == end {
        break
    }
    
    // Проверяем всех соседей
    for neighbor in 0..<n {
        if graph[current][neighbor] && distances[neighbor] == -1 {
            distances[neighbor] = distances[current] + 1
            queue.append(neighbor)
        }
    }
}

print(distances[end])
```

---
### 14. [Блохи](https://coderun.yandex.ru/problem/fleas)

**Условие задачи:**
На клеточном поле, размером NxM (2 ≤ N, M ≤ 250) сидит Q (0 ≤ Q ≤ 10000) блох в различных клетках. «Прием пищи» блохами возможен только в кормушке — одна из клеток поля, заранее известная. Блохи перемещаются по полю странным образом, а именно, прыжками, совпадающими с ходом обыкновенного шахматного коня. Длина пути каждой блохи до кормушки определяется как количество прыжков. Определить минимальное значение суммы длин путей блох до кормушки или, если собраться блохам у кормушки невозможно, то сообщить об этом. Сбор невозможен, если хотя бы одна из блох не может попасть к кормушке.

**Решение задачи:**

```swift
import Foundation

// Считываем входные данные
let line = readLine()!.split(separator: " ").map { Int($0)! }
let n = line[0]
let m = line[1]
let s = line[2] - 1 // Переводим в 0-индексацию
let t = line[3] - 1 // Переводим в 0-индексацию
let q = line[4]

// Создаем массив для хранения расстояний от каждой клетки до кормушки
var distances: [[Int]] = Array(repeating: Array(repeating: -1, count: m), count: n)

// Реализуем BFS из кормушки
var queue: [(Int, Int)] = [(s, t)]
distances[s][t] = 0

// Возможные ходы коня
let moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]

while !queue.isEmpty {
    let (row, col) = queue.removeFirst()
    
    // Проверяем все возможные ходы
    for (dr, dc) in moves {
        let newRow = row + dr
        let newCol = col + dc
        
        // Проверяем, что новая позиция внутри поля и еще не посещена
        if newRow >= 0 && newRow < n && newCol >= 0 && newCol < m && distances[newRow][newCol] == -1 {
            distances[newRow][newCol] = distances[row][col] + 1
            queue.append((newRow, newCol))
        }
    }
}

// Считаем сумму расстояний для всех блох
var totalDistance = 0
var isPossible = true

for _ in 0..<q {
    let flea = readLine()!.split(separator: " ").map { Int($0)! - 1 } // Переводим в 0-индексацию
    let fleaRow = flea[0]
    let fleaCol = flea[1]
    
    if distances[fleaRow][fleaCol] == -1 {
        isPossible = false
        break
    }
    
    totalDistance += distances[fleaRow][fleaCol]
}

if isPossible {
    print(totalDistance)
} else {
    print(-1)
}
```

---



### 15. [Путь спелеолога](https://coderun.yandex.ru/problem/speleologist-way)

**Условие задачи:**
Пещера представлена кубом, разбитым на N частей по каждому измерению (то есть на N^3 кубических клеток). Каждая клетка может быть или пустой, или полностью заполненной камнем. Исходя из положения спелеолога в пещере, требуется найти, какое минимальное количество перемещений по клеткам ему требуется, чтобы выбраться на поверхность. Переходить из клетки в клетку можно, только если они обе свободны и имеют общую грань.

**Решение задачи:**

```swift
import Foundation

// Считываем размер пещеры
let n = Int(readLine()!)!

// Создаем трехмерный массив для хранения пещеры
var cave: [[[Character]]] = []
var startLevel = 0
var startRow = 0
var startCol = 0

// Считываем описание пещеры
for level in 0..<n {
    _ = readLine() // Пустая строка
    var levelData: [[Character]] = []
    for row in 0..<n {
        let line = Array(readLine()!)
        levelData.append(line)
        
        // Ищем начальную позицию спелеолога
        if let col = line.firstIndex(of: "S") {
            startLevel = level
            startRow = row
            startCol = col
        }
    }
    cave.append(levelData)
}

// Реализуем BFS для поиска кратчайшего пути
var queue: [(Int, Int, Int)] = [(startLevel, startRow, startCol)]
var distances: [[[Int]]] = Array(repeating: Array(repeating: Array(repeating: -1, count: n), count: n), count: n)
distances[startLevel][startRow][startCol] = 0

// Возможные движения (вверх, вниз, север, юг, запад, восток)
let moves = [(-1, 0, 0), (1, 0, 0), (0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1)]

while !queue.isEmpty {
    let (level, row, col) = queue.removeFirst()
    
    // Если достигли поверхности (уровень 0), выводим результат
    if level == 0 {
        print(distances[level][row][col])
        exit(0)
    }
    
    // Проверяем все возможные движения
    for (dl, dr, dc) in moves {
        let newLevel = level + dl
        let newRow = row + dr
        let newCol = col + dc
        
        // Проверяем, что новая позиция внутри пещеры
        if newLevel >= 0 && newLevel < n && newRow >= 0 && newRow < n && newCol >= 0 && newCol < n {
            // Проверяем, что клетка свободна и еще не посещена
            if (cave[newLevel][newRow][newCol] == "." || cave[newLevel][newRow][newCol] == "S") && distances[newLevel][newRow][newCol] == -1 {
                distances[newLevel][newRow][newCol] = distances[level][row][col] + 1
                queue.append((newLevel, newRow, newCol))
            }
        }
    }
}
```

---
### 28. [НВП с восстановлением ответа](https://coderun.yandex.ru/problem/nvp-with-response-recovery)

**Условие задачи:**
Дана последовательность, требуется найти её наибольшую возрастающую подпоследовательность. Последовательность x называется подпоследовательностью последовательности y, если x получается из y удалением нескольких (возможно, нуля или всех) элементов. Наибольшая возрастающая подпоследовательность - строго возрастающая подпоследовательность наибольшей длины.

**Решение задачи:**

```swift
import Foundation

// Считываем длину последовательности
let n = Int(readLine()!)!

// Считываем саму последовательность
let sequence = readLine()!.split(separator: " ").map { Int($0)! }

// Массив для хранения длины НВП, заканчивающейся на i-ом элементе
var dp: [Int] = Array(repeating: 1, count: n)

// Массив для восстановления пути
var prev: [Int] = Array(repeating: -1, count: n)

// Заполняем массив dp
for i in 1..<n {
    for j in 0..<i {
        if sequence[j] < sequence[i] && dp[j] + 1 > dp[i] {
            dp[i] = dp[j] + 1
            prev[i] = j
        }
    }
}

// Находим индекс элемента, на котором заканчивается НВП максимальной длины
var maxLength = 0
var maxIndex = 0
for i in 0..<n {
    if dp[i] > maxLength {
        maxLength = dp[i]
        maxIndex = i
    }
}

// Восстанавливаем НВП
var result: [Int] = []
var currentIndex = maxIndex
while currentIndex != -1 {
    result.append(sequence[currentIndex])
    currentIndex = prev[currentIndex]
}

// Выводим результат
result.reversed().forEach { print($0, terminator: " ") }
print()
```

---

### 33. [Расстояние по Левенштейну](https://coderun.yandex.ru/problem/levenstein-distance)


**Условие задачи:**
Дана текстовая строка. С ней можно выполнять следующие операции: 1. Заменить один символ строки на другой символ. 2. Удалить один произвольный символ. 3. Вставить произвольный символ в произвольное место строки. Минимальное количество таких операций, при помощи которых можно из одной строки получить другую, называется стоимостью редактирования или расстоянием Левенштейна. Определите расстояние Левенштейна для двух данных строк.

**Решение задачи:**

```swift
import Foundation

// Считываем строки
let str1 = readLine()!
let str2 = readLine()!

let m = str1.count
let n = str2.count

// Создаем матрицу для динамического программирования
var dp: [[Int]] = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1)

// Преобразуем строки в массивы символов для удобства доступа
let arr1 = Array(str1)
let arr2 = Array(str2)

// Инициализируем первую строку и первый столбец
for i in 0...m {
    dp[i][0] = i
}
for j in 0...n {
    dp[0][j] = j
}

// Заполняем матрицу
for i in 1...m {
    for j in 1...n {
        if arr1[i - 1] == arr2[j - 1] {
            dp[i][j] = dp[i - 1][j - 1] // Символы совпадают, операция не нужна
        } else {
            // Выбираем минимальную стоимость среди трех операций
            dp[i][j] = min(
                dp[i - 1][j] + 1,     // Удаление
                dp[i][j - 1] + 1,     // Вставка
                dp[i - 1][j - 1] + 1  // Замена
            )
        }
    }
}

// Выводим результат
print(dp[m][n])
```

---

### 39. [Откуда достижима первая вершина](https://coderun.yandex.ru/problem/first-vertex)

**Условие задачи:**
Дан ориентированный граф, возможно, с петлями и кратными ребрами. Необходимо найти все вершины, из которых достижима первая вершина.

**Решение задачи:**

```swift
import Foundation

// Считываем количество вершин и ребер
let line = readLine()!.split(separator: " ").map { Int($0)! }
let n = line[0]
let m = line[1]

// Создаем список смежности для обратного графа
var reverseGraph: [[Int]] = Array(repeating: [], count: n + 1)

// Считываем ребра и строим обратный граф
for _ in 0..<m {
    let edge = readLine()!.split(separator: " ").map { Int($0)! }
    let from = edge[0]
    let to = edge[1]
    reverseGraph[to].append(from) // Переворачиваем направление ребра
}

// Реализуем DFS из первой вершины в обратном графе
var visited: [Bool] = Array(repeating: false, count: n + 1)
var stack: [Int] = [1] // Первая вершина (с номером 1)
visited[1] = true

while !stack.isEmpty {
    let current = stack.removeLast()
    
    // Проверяем всех предшественников в обратном графе
    for predecessor in reverseGraph[current] {
        if !visited[predecessor] {
            visited[predecessor] = true
            stack.append(predecessor)
        }
    }
}

// Выводим все достижимые вершины
for i in 1...n {
    if visited[i] {
        print(i)
    }
}
```

---


### 43. [Два коня](https://coderun.yandex.ru/problem/two-horses)

**Условие задачи:**
На стандартной шахматной доске (8х8) живут 2 шахматных коня: Красный и Зелёный. Обычно они беззаботно скачут по просторам доски, пощипывая шахматную травку, но сегодня особенный день: у Зелёного коня День Рождения. Зеленый конь решил отпраздновать это событие вместе с Красным. Но для осуществления этого прекрасного плана им нужно оказаться на одной клетке. Заметим, что Красный и Зелёный шахматные кони сильно отличаются от черного с белым: они ходят не по очереди, а одновременно, и если оказываются на одной клетке, никто никого не съедает. Сколько ходов им потребуется, чтобы насладиться праздником?

**Решение задачи:**

```swift
import Foundation

// Функция для преобразования шахматной нотации в координаты
func parsePosition(_ pos: String) -> (Int, Int) {
    let col = Int(pos.first!.asciiValue! - Character("a").asciiValue!) // 0-7
    let row = Int(String(pos.last!))! - 1 // 0-7
    return (row, col)
}

// Считываем позиции коней
let redPos = readLine()!
let greenPos = readLine()!

let (redRow, redCol) = parsePosition(redPos)
let (greenRow, greenCol) = parsePosition(greenPos)

// Если кони уже на одной клетке
if redRow == greenRow && redCol == greenCol {
    print(0)
    exit(0)
}

// BFS для поиска кратчайшего пути
// Состояние: (redRow, redCol, greenRow, greenCol)
var visited: [[[Bool]]] = Array(repeating: Array(repeating: Array(repeating: false, count: 8), count: 8), count: 8)
var queue: [(Int, Int, Int, Int, Int)] = [(redRow, redCol, greenRow, greenCol, 0)] // (redRow, redCol, greenRow, greenCol, steps)
visited[redRow][redCol][greenRow] = true

// Возможные ходы коня
let moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]

while !queue.isEmpty {
    let (rRow, rCol, gRow, gCol, steps) = queue.removeFirst()
    
    // Проверяем все возможные комбинации ходов
    for (dr1, dc1) in moves {
        let newRRow = rRow + dr1
        let newRCol = rCol + dc1
        
        // Проверяем, что позиция красного коня на доске
        if newRRow >= 0 && newRRow < 8 && newRCol >= 0 && newRCol < 8 {
            for (dr2, dc2) in moves {
                let newGRow = gRow + dr2
                let newGCol = gCol + dc2
                
                // Проверяем, что позиция зеленого коня на доске
                if newGRow >= 0 && newGRow < 8 && newGCol >= 0 && newGCol < 8 {
                    // Если кони встретились
                    if newRRow == newGRow && newRCol == newGCol {
                        print(steps + 1)
                        exit(0)
                    }
                    
                    // Если эта комбинация позиций еще не была посещена
                    if !visited[newRRow][newRCol][newGRow] {
                        visited[newRRow][newRCol][newGRow] = true
                        queue.append((newRRow, newRCol, newGRow, newGCol, steps + 1))
                    }
                }
            }
        }
    }
}

// Если не нашли путь
print(-1)
```

---

### 44. [Числа](https://coderun.yandex.ru/problem/numbers)

**Условие задачи:**
Витя хочет придумать новую игру с числами. В этой игре от игроков требуется преобразовывать четырехзначные числа не содержащие нулей при помощи следующего разрешенного набора действий: 1. Можно увеличить первую цифру числа на 1, если она не равна 9. 2. Можно уменьшить последнюю цифру на 1, если она не равна 1. 3. Можно циклически сдвинуть все цифры на одну вправо. 4. Можно циклически сдвинуть все цифры на одну влево. Например, применяя эти правила к числу 1234 можно получить числа 2234, 1233, 4123 и 2341 соответственно. Точные правила игры Витя пока не придумал, но пока его интересует вопрос, как получить из одного числа другое за минимальное количество операций.

**Решение задачи:**

```swift
import Foundation

// Функция для применения операций к числу
func applyOperation(_ number: Int, _ operation: Int) -> Int? {
    var digits = Array(String(number))
    
    switch operation {
    case 1: // Увеличить первую цифру на 1
        if digits[0] < "9" {
            digits[0] = Character(String(Int(String(digits[0]))! + 1))
            return Int(String(digits))!
        }
    case 2: // Уменьшить последнюю цифру на 1
        if digits[3] > "1" {
            digits[3] = Character(String(Int(String(digits[3]))! - 1))
            return Int(String(digits))!
        }
    case 3: // Циклический сдвиг вправо
        let lastDigit = digits.removeLast()
        digits.insert(lastDigit, at: 0)
        return Int(String(digits))!
    case 4: // Циклический сдвиг влево
        let firstDigit = digits.removeFirst()
        digits.append(firstDigit)
        return Int(String(digits))!
    default:
        break
    }
    
    return nil // Операция не может быть применена
}

// Считываем начальное и конечное числа
let start = Int(readLine()!)!
let end = Int(readLine()!)!

// Если числа совпадают
if start == end {
    print(start)
    exit(0)
}

// BFS для поиска кратчайшего пути
var visited: [Bool] = Array(repeating: false, count: 10000)
var queue: [(Int, [Int])] = [(start, [start])] // (число, путь)
visited[start] = true

while !queue.isEmpty {
    let (current, path) = queue.removeFirst()
    
    // Применяем все возможные операции
    for op in 1...4 {
        if let next = applyOperation(current, op) {
            // Если достигли конечного числа
            if next == end {
                let fullPath = path + [next]
                fullPath.forEach { print($0) }
                exit(0)
            }
            
            // Если это новое число, добавляем его в очередь
            if !visited[next] {
                visited[next] = true
                queue.append((next, path + [next]))
            }
        }
    }
}
```

---

### 45. [Числа](https://coderun.yandex.ru/problem/numbers)
**Условие задачи:**
Необходимо найти кратчайшую последовательность преобразований, которая переводит одно четырёхзначное число (без нулей) в другое, используя 4 типа операций:
1. Увеличить первую цифру на 1 (если не 9).
2. Уменьшить последнюю цифру на 1 (если не 1).
3. Циклический сдвиг вправо.
4. Циклический сдвиг влево.

**Идея решения:**
Это классическая задача на поиск кратчайшего пути в графе. Вершины графа — все возможные четырёхзначные числа без нулей, рёбра — возможные переходы по операциям. Для поиска кратчайшего пути используем **BFS (поиск в ширину)**.

---

**Решение задачи:**

```swift
import Foundation

// Функция для получения всех возможных следующих чисел
func getNextNumbers(_ num: String) -> [String] {
    var result: [String] = []
    var digits = Array(num)
    
    // 1. Увеличить первую цифру на 1, если не 9
    if digits[0] < "9" {
        var newDigits = digits
        newDigits[0] = String(Character(UnicodeScalar(digits[0].unicodeScalars.first!.value + 1)!))
        result.append(String(newDigits))
    }
    
    // 2. Уменьшить последнюю цифру на 1, если не 1
    if digits[3] > "1" {
        var newDigits = digits
        newDigits[3] = String(Character(UnicodeScalar(digits[3].unicodeScalars.first!.value - 1)!))
        result.append(String(newDigits))
    }
    
    // 3. Циклический сдвиг вправо: 1234 -> 4123
    result.append(String(digits[3]) + String(digits[0]) + String(digits[1]) + String(digits[2]))
    
    // 4. Циклический сдвиг влево: 1234 -> 2341
    result.append(String(digits[1]) + String(digits[2]) + String(digits[3]) + String(digits[0]))
    
    return result
}

// Чтение входных данных
let input = readLine()!.split(separator: " ").map { String($0) }
let start = input[0]
let target = input[1]

// BFS
var queue: [(number: String, path: [String])] = [(start, [start])]
var visited: Set<String> = [start]

while !queue.isEmpty {
    let (current, path) = queue.removeFirst()
    
    if current == target {
        // Нашли путь, выводим его
        for number in path {
            print(number)
        }
        break
    }
    
    for next in getNextNumbers(current) {
        if !visited.contains(next) {
            visited.insert(next)
            queue.append((next, path + [next]))
        }
    }
}
```

---

### 51. [Номер появления слова](https://coderun.yandex.ru/problem/word-appearance-number)

**Условие задачи:**
Во входном файле (вы можете читать данные из файла input.txt) записан текст. Словом считается последовательность непробельных символов идущих подряд, слова разделены одним или большим числом пробелов или символами конца строки. Для каждого слова из этого текста подсчитайте, сколько раз оно встречалось в этом тексте ранее.

**Решение задачи:**

```swift
import Foundation

// Словарь для хранения количества появлений каждого слова
var wordCount: [String: Int] = [:]

// Читаем весь текст
var text = ""
while let line = readLine() {
    text += line + " "
}

// Разбиваем текст на слова
let words = text.split(separator: " ").map { String($0) }

// Обрабатываем каждое слово
for word in words {
    let count = wordCount[word, default: 0]
    print(count)
    wordCount[word, default: 0] += 1
}
```

### 52. [Словарь синонимов](https://coderun.yandex.ru/problem/dictionary-synonyms)


**Условие задачи:**
Вам дан словарь, состоящий из пар слов. Каждое слово является синонимом к парному ему слову. Все слова в словаре различны. Для одного данного слова определите его синоним.

**Решение задачи:**

```swift
import Foundation

// Считываем количество пар синонимов
let n = Int(readLine()!)!

// Создаем словарь для хранения синонимов
var synonyms: [String: String] = [:]

// Считываем пары синонимов
for _ in 0..<n {
    let pair = readLine()!.split(separator: " ").map { String($0) }
    let word1 = pair[0]
    let word2 = pair[1]
    
    synonyms[word1] = word2
    synonyms[word2] = word1
}

// Считываем слово, для которого нужно найти синоним
let word = readLine()!

// Выводим синоним
print(synonyms[word]!)
```

---


### 54. [Полиглоты](https://coderun.yandex.ru/problem/polyglots)


**Условие задачи:**
Каждый из N школьников некоторой школы знает M_i языков. Определите, какие языки знают все школьники и языки, которые знает хотя бы один из школьников.

**Решение задачи:**

```swift
import Foundation

// Считываем количество школьников
let n = Int(readLine()!)!

var allLanguages: Set<String> = Set<String>()
var commonLanguages: Set<String>? = nil

// Обрабатываем каждого школьника
for i in 0..<n {
    // Считываем количество языков у школьника
    let m = Int(readLine()!)!
    
    // Считываем языки школьника
    var studentLanguages: Set<String> = Set<String>()
    for _ in 0..<m {
        studentLanguages.insert(readLine()!)
    }
    
    // Добавляем языки в множество всех языков
    allLanguages = allLanguages.union(studentLanguages)
    
    // Для первого школьника инициализируем commonLanguages
    if commonLanguages == nil {
        commonLanguages = studentLanguages
    } else {
        // Находим пересечение с языками предыдущих школьников
        commonLanguages = commonLanguages!.intersection(studentLanguages)
    }
}

// Выводим результаты
let common = commonLanguages!.sorted()
print(common.count)
for language in common {
    print(language)
}

let all = allLanguages.sorted()
print(all.count)
for language in all {
    print(language)
}
```

---


### 55. [Злые свинки](https://coderun.yandex.ru/problem/angry-pigs)

**Условие задачи:**
Птицы в игре представляются точками на плоскости. Выстрел сбивает только ближайшую птицу находящуюся на линии огня. При этом сбитая птица, падая, сбивает всех птиц, находящихся ровно под ней. Две птицы не могут находиться в одной точке. По заданному расположению птиц необходимо определить, какое минимальное количество выстрелов необходимо, чтобы все птицы были сбиты.

**Решение задачи:**

```swift
import Foundation

// Считываем количество птиц
let n = Int(readLine()!)!

// Словарь для хранения множества y-координат для каждой x-координаты
var xCoords: [Int: Set<Int>] = [:]

// Считываем координаты птиц
for _ in 0..<n {
    let coords = readLine()!.split(separator: " ").map { Int($0)! }
    let x = coords[0]
    let y = coords[1]
    
    if xCoords[x] == nil {
        xCoords[x] = Set<Int>()
    }
    xCoords[x]!.insert(y)
}

// Минимальное количество выстрелов равно количеству уникальных x-координат
print(xCoords.count)
```

---

### 57. [Инопланетный геном](https://coderun.yandex.ru/problem/alien-genome)

**Условие задачи:**
Геном жителей системы Тау Кита содержит 26 видов оснований, для обозначения которых будем использовать буквы латинского алфавита от A до Z. Важную роль в геноме играют пары соседних оснований. Степенью близости одного генома другому геному называется количество пар соседних оснований первого генома, которые встречаются во втором геноме. Определите степень близости первого генома второму геному.

**Решение задачи:**

```swift
import Foundation

// Считываем первый геном
let genome1 = readLine()!

// Считываем второй геном
let genome2 = readLine()!

// Создаем множество пар оснований из второго генома
var pairsGenome2: Set<String> = []
for i in 0..<genome2.count - 1 {
    let startIndex = genome2.index(genome2.startIndex, offsetBy: i)
    let endIndex = genome2.index(startIndex, offsetBy: 2)
    let pair = String(genome2[startIndex..<endIndex])
    pairsGenome2.insert(pair)
}

// Подсчитываем количество пар из первого генома, которые есть во втором
var similarity = 0
for i in 0..<genome1.count - 1 {
    let startIndex = genome1.index(genome1.startIndex, offsetBy: i)
    let endIndex = genome1.index(startIndex, offsetBy: 2)
    let pair = String(genome1[startIndex..<endIndex])
    if pairsGenome2.contains(pair) {
        similarity += 1
    }
}

// Выводим степень близости
print(similarity)
```

---



### 58. [OpenCalculator](https://coderun.yandex.ru/problem/open-calculator)

**Условие задачи:**
В новой программе OpenCalculator появилась новая возможность – можно настроить, какие кнопки отображаются. Петя настроил калькулятор так, что он отображает только кнопки с цифрами x, y, z. Определите, сможет ли Петя ввести число N, а если нет, то какое минимальное количество кнопок надо дополнительно отобразить на экране для его ввода.

**Решение задачи:**

```swift
import Foundation

// Считываем доступные цифры
let availableDigits = Set(readLine()!.split(separator: " ").map { Int(String($0.first!))! })

// Считываем число N
let n = readLine()!

// Находим уникальные цифры в числе N
let requiredDigits = Set(n.compactMap { Int(String($0)) })

// Находим цифры, которых не хватает
let missingDigits = requiredDigits.subtracting(availableDigits)

// Выводим количество недостающих цифр
print(missingDigits.count)
```

---

### 60. [Кубики](https://coderun.yandex.ru/problem/cubes)

**Условие задачи:**
Аня и Боря любят играть в разноцветные кубики. У каждого из них свой набор, и в каждом наборе все кубики различны по цвету. Номер любого цвета — это целое число в пределах от 0 до 10⁹. Определите:
1. Количество цветов, которые есть в обоих наборах.
2. Отсортированные номера этих цветов.
3. Количество цветов, которые есть только у Ани.
4. Отсортированные номера этих цветов.
5. Количество цветов, которые есть только у Бори.
6. Отсортированные номера этих цветов.

**Решение задачи:**

```swift
import Foundation

// Считываем количество кубиков у Ани и Бори
let nm = readLine()!.split(separator: " ").map { Int($0)! }
let n = nm[0] // Количество кубиков у Ани
let m = nm[1] // Количество кубиков у Бори

// Считываем номера цветов кубиков Ани
var annaColors: Set<Int> = []
for _ in 0..<n {
    annaColors.insert(Int(readLine()!)!)
}

// Считываем номера цветов кубиков Бори
var borisColors: Set<Int> = []
for _ in 0..<m {
    borisColors.insert(Int(readLine()!)!)
}

// Находим цвета, которые есть у обоих
let commonColors = annaColors.intersection(borisColors).sorted()
print(commonColors.count)
if !commonColors.isEmpty {
    print(commonColors.map { String($0) }.joined(separator: " "))
}

// Находим цвета, которые есть только у Ани
let onlyAnnaColors = annaColors.subtracting(borisColors).sorted()
print(onlyAnnaColors.count)
if !onlyAnnaColors.isEmpty {
    print(onlyAnnaColors.map { String($0) }.joined(separator: " "))
}

// Находим цвета, которые есть только у Бори
let onlyBorisColors = borisColors.subtracting(annaColors).sorted()
print(onlyBorisColors.count)
if !onlyBorisColors.isEmpty {
    print(onlyBorisColors.map { String($0) }.joined(separator: " "))
}
```

---


### 61. [Пересечение множеств](https://coderun.yandex.ru/problem/intersection-sets)

**Условие задачи:**
Даны два списка чисел, которые могут содержать до 10000 чисел каждый. Выведите все числа, которые входят как в первый, так и во второй список в порядке возрастания.

**Решение задачи:**

```swift
import Foundation

// Считываем первый список чисел
let list1 = Set(readLine()!.split(separator: " ").map { Int($0)! })

// Считываем второй список чисел
let list2 = Set(readLine()!.split(separator: " ").map { Int($0)! })

// Находим пересечение множеств
let intersection = list1.intersection(list2).sorted()

// Выводим результат
print(intersection.map { String($0) }.joined(separator: " "))
```

---


### 62. [Количество различных чисел](https://coderun.yandex.ru/problem/number-different-numbers)

**Условие задачи:**
Дан список чисел, который может содержать до 100000 чисел. Определите, сколько в нём встречается различных чисел.

**Решение задачи:**

```swift
import Foundation

// Считываем список чисел
let numbers = readLine()!.split(separator: " ").map { Int($0)! }

// Используем Set для хранения уникальных чисел
let uniqueNumbers = Set(numbers)

// Выводим количество уникальных чисел
print(uniqueNumbers.count)
```

---

### 64. [Сапёр](https://coderun.yandex.ru/problem/sapper)

**Условие задачи:**
Вам необходимо построить поле для игры «Сапер» по его конфигурации — размерам и координатам расставленных на нём мин. Поле состоит из клеток с минами и пустых клеток. Клетки с миной обозначаются символом `*`. Пустые клетки содержат число `k_{i,j}`, `0 ≤ k_{i,j} ≤ 8` — количество мин на соседних клетках. Соседними клетками являются восемь клеток, имеющих смежный угол или сторону.

**Решение задачи:**

```swift
import Foundation

// Считываем размеры поля и количество мин
let firstLine = readLine()!.split(separator: " ").map { Int($0)! }
let n = firstLine[0] // Количество строк
let m = firstLine[1] // Количество столбцов
let k = firstLine[2] // Количество мин

// Создаем поле и инициализируем его нулями
var field: [[Int]] = Array(repeating: Array(repeating: 0, count: m), count: n)

// Создаем булев массив для отметки мин
var mines: [[Bool]] = Array(repeating: Array(repeating: false, count: m), count: n)

// Считываем координаты мин и отмечаем их
for _ in 0..<k {
    let mineCoords = readLine()!.split(separator: " ").map { Int($0)! - 1 } // Переводим в 0-индексацию
    let row = mineCoords[0]
    let col = mineCoords[1]
    mines[row][col] = true
}

// Для каждой клетки без мины подсчитываем количество соседних мин
let directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]

for i in 0..<n {
    for j in 0..<m {
        if !mines[i][j] { // Если в клетке нет мины
            var count = 0
            for (dx, dy) in directions {
                let ni = i + dx
                let nj = j + dy
                if ni >= 0 && ni < n && nj >= 0 && nj < m && mines[ni][nj] {
                    count += 1
                }
            }
            field[i][j] = count
        }
    }
}

// Выводим поле
for i in 0..<n {
    for j in 0..<m {
        if mines[i][j] {
            print("*", terminator: " ")
        } else {
            print(field[i][j], terminator: " ")
        }
    }
    print() // Новая строка после каждой строки поля
}
```

---


### 69. [Больше своих соседей](https://coderun.yandex.ru/problem/more-your-neighbors)

**Условие задачи:**
Дан список чисел. Определите, сколько в этом списке элементов, которые больше двух своих соседей. Выведите количество таких элементов.

**Решение задачи:**

```swift
import Foundation

// Считываем список чисел
let numbers = readLine()!.split(separator: " ").map { Int($0)! }

// Подсчитываем количество элементов, больших своих соседей
var count = 0

// Проверяем элементы с 1 по n-2 (у них есть оба соседа)
for i in 1..<(numbers.count - 1) {
    if numbers[i] > numbers[i-1] && numbers[i] > numbers[i+1] {
        count += 1
    }
}

print(count)
```


### 70. [Ближайшее число](https://coderun.yandex.ru/problem/nearest-number)

**Условие задачи:**
Напишите программу, которая находит в массиве элемент, самый близкий по величине к данному числу.

**Решение задачи:**

```swift
import Foundation

// Считываем размер массива
let n = Int(readLine()!)!

// Считываем элементы массива
let array = readLine()!.split(separator: " ").map { Int($0)! }

// Считываем число x
let x = Int(readLine()!)!

// Находим элемент, самый близкий к x
var closest = array[0]
var minDifference = abs(array[0] - x)

for i in 1..<array.count {
    let difference = abs(array[i] - x)
    if difference < minDifference {
        minDifference = difference
        closest = array[i]
    }
}

print(closest)
```

---

### 71. [Определить вид последовательности](https://coderun.yandex.ru/problem/determine-type-sequence)

**Условие задачи:**
По последовательности чисел во входных данных определите ее вид:
* CONSTANT — последовательность состоит из одинаковых значений
* ASCENDING — последовательность является строго возрастающей
* WEAKLY ASCENDING — последовательность является нестрого возрастающей
* DESCENDING — последовательность является строго убывающей
* WEAKLY DESCENDING — последовательность является нестрого убывающей
* RANDOM — последовательность не принадлежит ни к одному из вышеупомянутых типов

**Решение задачи:**

```swift
import Foundation

// Считываем последовательность чисел
var numbers: [Int] = []
while let line = readLine(), let number = Int(line), number != -2000000000 {
    numbers.append(number)
}

// Определяем вид последовательности
if numbers.count <= 1 {
    print("CONSTANT")
} else {
    var isConstant = true
    var isAscending = true
    var isWeaklyAscending = true
    var isDescending = true
    var isWeaklyDescending = true
    
    for i in 1..<numbers.count {
        if numbers[i] != numbers[i-1] {
            isConstant = false
        }
        if numbers[i] <= numbers[i-1] {
            isAscending = false
        }
        if numbers[i] < numbers[i-1] {
            isWeaklyAscending = false
        }
        if numbers[i] >= numbers[i-1] {
            isDescending = false
        }
        if numbers[i] > numbers[i-1] {
            isWeaklyDescending = false
        }
    }
    
    if isConstant {
        print("CONSTANT")
    } else if isAscending {
        print("ASCENDING")
    } else if isWeaklyAscending {
        print("WEAKLY ASCENDING")
    } else if isDescending {
        print("DESCENDING")
    } else if isWeaklyDescending {
        print("WEAKLY DESCENDING")
    } else {
        print("RANDOM")
    }
}
```

---

### 72. [Возрастает ли список?](https://coderun.yandex.ru/problem/list-growing)

**Условие задачи:**
Дан список. Определите, является ли он монотонно возрастающим (то есть верно ли, что каждый элемент этого списка строго больше предыдущего). Выведите YES, если массив монотонно возрастает и NO в противном случае.

**Решение задачи:**

```swift
import Foundation

// Считываем список чисел
let numbers = readLine()!.split(separator: " ").map { Int($0)! }

// Проверяем, является ли список строго возрастающим
var isIncreasing = true

if numbers.count > 1 {
    for i in 1..<numbers.count {
        if numbers[i] <= numbers[i-1] {
            isIncreasing = false
            break
        }
    }
}

if isIncreasing {
    print("YES")
} else {
    print("NO")
}
```

---


### 74. [Узник замка Иф](https://coderun.yandex.ru/problem/castle-if)

**Условие задачи:**
За многие годы заточения узник замка Иф проделал в стене прямоугольное отверстие размером `D × E`. Замок Иф сложен из кирпичей, размером `A × B × C`. Определите, сможет ли узник выбрасывать кирпичи в море через это отверстие, если стороны кирпича должны быть параллельны сторонам отверстия.

**Решение задачи:**

```swift
import Foundation

// Считываем размеры кирпича
let brickDimensions = readLine()!.split(separator: " ").map { Int($0)! }
let a = brickDimensions[0]
let b = brickDimensions[1]
let c = brickDimensions[2]

// Считываем размеры отверстия
let holeDimensions = readLine()!.split(separator: " ").map { Int($0)! }
let d = holeDimensions[0]
let e = holeDimensions[1]

// Сортируем размеры кирпича и отверстия
let sortedBrick = [a, b, c].sorted()
let sortedHole = [d, e].sorted()

// Проверяем, можно ли протолкнуть кирпич через отверстие
// Кирпич можно повернуть, поэтому проверяем все возможные ориентации
// Нам нужно, чтобы две самые маленькие стороны кирпича были <= соответствующих сторон отверстия
if sortedBrick[0] <= sortedHole[0] && sortedBrick[1] <= sortedHole[1] {
    print("YES")
} else {
    print("NO")
}
```

---


### 80. [Телефонные номера](https://coderun.yandex.ru/problem/phone-numbers)

**Условие задачи:**
Телефонные номера в адресной книге мобильного телефона имеют один из следующих форматов: +7<код><номер>, 8<код><номер>, <номер>, где <номер> — это семь цифр, а <код> — это три цифры или три цифры в круглых скобках. Если код не указан, то считается, что он равен 495. Кроме того, в записи телефонного номера может стоять знак “-” между любыми двумя цифрами. На данный момент в адресной книге телефона Васи записано всего три телефонных номера и он хочет записать туда ещё один. Но он не может понять, не записан ли уже такой номер в телефонной книге. Помогите ему! Два телефонных номера совпадают, если у них равны коды и равны номера. Например, +7(916)0123456 и 89160123456 — это один и тот же номер.

**Решение задачи:**

```swift
import Foundation

// Функция для нормализации номера телефона
func normalizePhoneNumber(_ phone: String) -> (code: String, number: String) {
    // Удаляем все нецифровые символы
    let digits = phone.filter { $0.isNumber }
    
    // Определяем код и номер
    let code: String
    let number: String
    
    if digits.count == 11 {
        // Номер начинается с 7 или 8
        if digits.first == "7" || digits.first == "8" {
            code = String(digits.dropFirst().prefix(3))
            number = String(digits.suffix(7))
        } else {
            // Это случай, когда 11 цифр, но не начинается с 7 или 8
            // Скорее всего, это ошибка, но обработаем по аналогии
            code = String(digits.prefix(3))
            number = String(digits.suffix(7))
        }
    } else if digits.count == 10 {
        // Номер начинается с кода
        code = String(digits.prefix(3))
        number = String(digits.suffix(7))
    } else {
        // Номер без кода, код по умолчанию 495
        code = "495"
        number = digits
    }
    
    return (code, number)
}

// Считываем номер, который Вася хочет добавить
let newPhone = readLine()!
let normalizedNewPhone = normalizePhoneNumber(newPhone)

// Считываем три номера из адресной книги
for _ in 0..<3 {
    let existingPhone = readLine()!
    let normalizedExistingPhone = normalizePhoneNumber(existingPhone)
    
    // Сравниваем коды и номера
    if normalizedNewPhone.code == normalizedExistingPhone.code && 
       normalizedNewPhone.number == normalizedExistingPhone.number {
        print("YES")
    } else {
        print("NO")
    }
}
```

---


### 81. [Треугольник](https://coderun.yandex.ru/problem/triangle)

**Условие задачи:**
Даны три натуральных числа. Возможно ли построить треугольник с такими сторонами? Если это возможно, выведите строку YES, иначе выведите строку NO. Треугольник — это три точки, не лежащие на одной прямой.

**Решение задачи:**

```swift
import Foundation

// Считываем три числа - стороны треугольника
let sides = readLine()!.split(separator: " ").map { Int($0)! }

// Сортируем стороны для удобства проверки
let sortedSides = sides.sorted()

// Проверяем неравенство треугольника
// Сумма двух меньших сторон должна быть больше третьей стороны
if sortedSides[0] + sortedSides[1] > sortedSides[2] {
    print("YES")
} else {
    print("NO")
}
```

---

### 82. [Кондиционер](https://coderun.yandex.ru/problem/conditioner)

**Условие задачи:**
В офисе, где работает программист Пётр, установили кондиционер нового типа. Этот кондиционер отличается особой простотой в управлении. У кондиционера есть всего лишь два управляемых параметра: желаемая температура и режим работы. Кондиционер может работать в четырёх режимах: «freeze» — охлаждение. В этом режиме кондиционер может только уменьшать температуру. Если температура в комнате и так не больше желаемой, то он выключается. «heat» — нагрев. В этом режиме кондиционер может только увеличивать температуру. Если температура в комнате и так не меньше желаемой, то он выключается. «auto» — автоматический режим. В этом режиме кондиционер может как увеличивать, так и уменьшать температуру в комнате до желаемой. «fan» — вентиляция. В этом режиме кондиционер осуществляет только вентиляцию воздуха и не изменяет температуру в комнате. Кондиционер достаточно мощный, поэтому при настройке на правильный режим работы он за час доводит температуру в комнате до желаемой. Требуется написать программу, которая по заданной температуре в комнате `t_room`, установленным на кондиционере желаемой температуре `t_cond` и режиму работы определяет температуру, которая установится в комнате через час.

**Решение задачи:**

```swift
import Foundation

// Считываем температуры
let temperatures = readLine()!.split(separator: " ").map { Int($0)! }
let tRoom = temperatures[0]
let tCond = temperatures[1]

// Считываем режим работы
let mode = readLine()!

// Определяем температуру через час в зависимости от режима
let resultTemp: Int
switch mode {
case "freeze":
    resultTemp = min(tRoom, tCond)
case "heat":
    resultTemp = max(tRoom, tCond)
case "auto":
    resultTemp = tCond
case "fan":
    resultTemp = tRoom
default:
    resultTemp = tRoom // На случай некорректного режима
}

print(resultTemp)
```

---

### 83. [Клавиатура](https://coderun.yandex.ru/problem/keyboard)

**Условие задачи:**
На региональном этапе Всероссийской олимпиады школьников по информатике в 2009 году предлагалась следующая задача. Всем известно, что со временем клавиатура изнашивается, и клавиши на ней начинают залипать. Конечно, некоторое время такую клавиатуру ещё можно использовать, но для нажатий клавиш приходиться использовать большую силу. При изготовлении клавиатуры изначально для каждой клавиши задается количество нажатий, которое она должна выдерживать. Если знать эти величины для используемой клавиатуры, то для определенной последовательности нажатых клавиш можно определить, какие клавиши в процессе их использования сломаются, а какие — нет. Требуется написать программу, определяющую, какие клавиши сломаются в процессе заданного варианта эксплуатации клавиатуры.

**Решение задачи:**

```swift
import Foundation

// Считываем количество клавиш
let n = Int(readLine()!)!

// Считываем количество нажатий, которое выдерживает каждая клавиша
let durability = readLine()!.split(separator: " ").map { Int($0)! }

// Считываем общее количество нажатий
let k = Int(readLine()!)!

// Считываем последовательность нажатых клавиш
let presses = readLine()!.split(separator: " ").map { Int($0)! }

// Создаем массив для подсчета нажатий на каждую клавишу
var pressCount = Array(repeating: 0, count: n)

// Подсчитываем количество нажатий на каждую клавишу
for press in presses {
    let keyIndex = press - 1 // Переводим в 0-индексацию
    pressCount[keyIndex] += 1
}

// Определяем, сломаются ли клавиши
for i in 0..<n {
    if pressCount[i] > durability[i] {
        print("YES")
    } else {
        print("NO")
    }
}
```

---


### 84. [Пирамида](https://coderun.yandex.ru/problem/pyramid)

**Условие задачи:**
Для строительства двумерной пирамиды используются прямоугольные блоки, каждый из которых характеризуется шириной и высотой. Можно поставить один блок на другой, только если ширина верхнего блока строго меньше ширины нижнего (блоки нельзя поворачивать). Самым нижним в пирамиде может быть блок любой ширины. По заданному набору блоков определите, пирамиду какой наибольшей высоты можно из них построить.

**Решение задачи:**

```swift
import Foundation

// Считываем количество блоков
let n = Int(readLine()!)!

// Считываем блоки и сортируем по ширине в порядке убывания
var blocks: [(width: Int, height: Int)] = []
for _ in 0..<n {
    let wh = readLine()!.split(separator: " ").map { Int($0)! }
    blocks.append((wh[0], wh[1]))
}

blocks.sort { $0.width > $1.width }

// Используем динамическое программирование для нахождения максимальной высоты
var maxHeight = 0
var dp: [Int] = Array(repeating: 0, count: n)

for i in 0..<n {
    dp[i] = blocks[i].height // Высота пирамиды, заканчивающейся на блоке i
    
    // Проверяем все предыдущие блоки
    for j in 0..<i {
        // Если блок j может быть под блоком i
        if blocks[j].width > blocks[i].width {
            dp[i] = max(dp[i], dp[j] + blocks[i].height)
        }
    }
    
    maxHeight = max(maxHeight, dp[i])
}

print(maxHeight)
```



### 86. [Банковские счета](https://coderun.yandex.ru/problem/bank-accounts)

**Условие задачи:**
Некоторый банк хочет внедрить систему управления счетами клиентов, поддерживающую следующие операции: Пополнение счета клиента. Снятие денег со счёта. Запрос остатка средств на счёте. Перевод денег между счетами клиентов. Начисление процентов всем клиентам. Вам необходимо реализовать такую систему. Клиенты банка идентифицируются именами (уникальная строка, не содержащая пробелов). Первоначально у банка нет ни одного клиента. Как только для клиента проводится операция пополнения, снятия или перевода денег, ему заводится счёт с нулевым балансом. Все дальнейшие операции проводятся только с этим счётом. Сумма на счету может быть как положительной, так и отрицательной, при этом всегда является целым числом.

**Решение задачи:**

```swift
import Foundation

// Словарь для хранения балансов клиентов
var balances: [String: Int] = [:]

// Функция для получения баланса клиента (если счета нет, создаем с нулевым балансом)
func getBalance(_ name: String) -> Int {
    if balances[name] == nil {
        balances[name] = 0
    }
    return balances[name]!
}

// Функция для установки баланса клиента
func setBalance(_ name: String, _ amount: Int) {
    balances[name] = amount
}

// Обрабатываем команды
while let line = readLine(), !line.isEmpty {
    let parts = line.split(separator: " ").map { String($0) }
    let command = parts[0]
    
    switch command {
    case "DEPOSIT":
        let name = parts[1]
        let amount = Int(parts[2])!
        setBalance(name, getBalance(name) + amount)
        
    case "WITHDRAW":
        let name = parts[1]
        let amount = Int(parts[2])!
        setBalance(name, getBalance(name) - amount)
        
    case "BALANCE":
        let name = parts[1]
        if balances[name] != nil {
            print(getBalance(name))
        } else {
            print("ERROR")
        }
        
    case "TRANSFER":
        let name1 = parts[1]
        let name2 = parts[2]
        let amount = Int(parts[3])!
        setBalance(name1, getBalance(name1) - amount)
        setBalance(name2, getBalance(name2) + amount)
        
    case "INCOME":
        let percent = Int(parts[1])!
        for (name, balance) in balances {
            if balance > 0 {
                let income = balance * percent / 100
                setBalance(name, balance + income)
            }
        }
        
    default:
        break
    }
}
```

---

### 88. [Контрольная по ударениям](https://coderun.yandex.ru/problem/control-accent)

**Условие задачи:**
Учительница задала Пете домашнее задание — в заданном тексте расставить ударения в словах, после чего поручила Васе проверить это домашнее задание. Вася очень плохо знаком с данной темой, поэтому он нашел словарь, в котором указано, как ставятся ударения в словах. К сожалению, в этом словаре присутствуют не все слова. Вася решил, что в словах, которых нет в словаре, он будет считать, что Петя поставил ударения правильно, если в этом слове Петей поставлено ровно одно ударение. Оказалось, что в некоторых словах ударение может быть поставлено больше, чем одним способом. Вася решил, что в этом случае если то, как Петя поставил ударение, соответствует одному из приведённых в словаре вариантов, он будет засчитывать это как правильную расстановку ударения, а если не соответствует, то как ошибку. Вам дан словарь, которым пользовался Вася и домашнее задание, сданное Петей. Ваша задача — определить количество ошибок, которое в этом задании насчитает Вася.

**Решение задачи:**

```swift
import Foundation

// Считываем количество слов в словаре
let n = Int(readLine()!)!

// Словарь для хранения правильных вариантов ударений
var accentDictionary: [String: Set<String>] = [:]

// Считываем слова из словаря
for _ in 0..<n {
    let word = readLine()!
    let lowercasedWord = word.lowercased()
    if accentDictionary[lowercasedWord] == nil {
        accentDictionary[lowercasedWord] = Set<String>()
    }
    accentDictionary[lowercasedWord]!.insert(word)
}

// Считываем текст Пети
let peteText = readLine()!

// Разбиваем текст на слова
let words = peteText.split(separator: " ").map { String($0) }

var errorCount = 0

// Проверяем каждое слово
for word in words {
    let lowercasedWord = word.lowercased()
    let accentCount = word.filter { $0.isUppercase }.count
    
    // Если нет заглавных букв или больше одной заглавной буквы - ошибка
    if accentCount != 1 {
        errorCount += 1
        continue
    }
    
    // Если слово есть в словаре
    if let validAccents = accentDictionary[lowercasedWord] {
        // Проверяем, совпадает ли ударение с одним из вариантов в словаре
        if !validAccents.contains(word) {
            errorCount += 1
        }
    }
    // Если слова нет в словаре, то по условию оно считается правильным (т.к. accentCount == 1)
}

print(errorCount)
```

---

### 91. [Сумма номеров](https://coderun.yandex.ru/problem/sum-of-numbers)

**Условие задачи:**
Вася очень любит везде искать своё счастливое число K. Каждый день он ходит в школу по улице, вдоль которой припарковано N машин. Он заинтересовался вопросом, сколько существует отрезков из подряд идущих машин таких, что сумма их номеров равна K. Помогите Васе узнать ответ на его вопрос.

**Решение задачи:**

```swift
import Foundation

// Считываем входные данные
let nk = readLine()!.split(separator: " ").map { Int($0)! }
let n = nk[0] // Количество машин
let k = nk[1] // Счастливое число

// Считываем номера машин
let carNumbers = readLine()!.split(separator: " ").map { Int($0)! }

var count = 0
var prefixSum = 0
var sumCount: [Int: Int] = [0: 1] // Словарь для хранения количества префиксных сумм

// Используем метод префиксных сумм
for i in 0..<n {
    prefixSum += carNumbers[i]
    
    // Проверяем, существует ли префиксная сумма (prefixSum - k)
    if let existingCount = sumCount[prefixSum - k] {
        count += existingCount
    }
    
    // Обновляем словарь с текущей префиксной суммой
    sumCount[prefixSum, default: 0] += 1
}

print(count)
```

---

### 93. [Город Че](https://coderun.yandex.ru/problem/city-of-che)

**Условие задачи:**
В центре города Че есть пешеходная улица - одно из самых популярных мест для прогулок жителей города. По этой улице очень приятно гулять, ведь вдоль улицы расположено n забавных памятников. Девочке Маше из города Че нравятся два мальчика из её школы, и она никак не может сделать выбор между ними. Чтобы принять окончательное решение, она решила назначить обоим мальчикам свидание в одно и то же время. Маша хочет выбрать два памятника на пешеходной улице, около которых мальчики будут её ждать. При этом она хочет выбрать такие памятники, чтобы мальчики не увидели друг друга. Маша знает, что из-за тумана мальчики увидят друг друга только в том случае, если они будут на расстоянии не более r метров. Маша заинтересовалась, а сколько способов есть выбрать два различных памятника для организации свиданий?

**Решение задачи:**

```swift
import Foundation

// Считываем входные данные
let nr = readLine()!.split(separator: " ").map { Int($0)! }
let n = nr[0] // Количество памятников
let r = nr[1] // Максимальное расстояние, на котором мальчики могут увидеть друг друга

// Считываем расстояния памятников от начала улицы
let distances = readLine()!.split(separator: " ").map { Int($0)! }

var count = 0

// Для каждого памятника i находим количество памятников j (j > i), таких что расстояние > r
for i in 0..<n {
    // Используем бинарный поиск для нахождения первого памятника, который находится на расстоянии > r от памятника i
    let targetDistance = distances[i] + r
    var left = i + 1
    var right = n
    
    while left < right {
        let mid = (left + right) / 2
        if distances[mid] > targetDistance {
            right = mid
        } else {
            left = mid + 1
        }
    }
    
    // Количество подходящих памятников для памятника i
    count += n - left
}

print(count)
```

---



### 96. [Подстрока](https://coderun.yandex.ru/problem/substring)

**Условие задачи:**
В этой задаче Вам требуется найти максимальную по длине подстроку данной строки, такую что каждый символ встречается в ней не более k раз.

**Решение задачи:**

```swift
import Foundation

// Считываем входные данные
let nk = readLine()!.split(separator: " ").map { Int($0)! }
let n = nk[0] // Длина строки
let k = nk[1] // Максимальное количество повторений символа

// Считываем строку
let s = readLine()!

// Используем алгоритм двух указателей
var charCount: [Character: Int] = [:]
var left = 0
var maxLength = 0
var bestStart = 0

for right in 0..<n {
    let rightChar = s[s.index(s.startIndex, offsetBy: right)]
    charCount[rightChar, default: 0] += 1
    
    // Если какой-то символ встречается больше k раз, сдвигаем левый указатель
    while charCount[rightChar]! > k {
        let leftChar = s[s.index(s.startIndex, offsetBy: left)]
        charCount[leftChar]! -= 1
        if charCount[leftChar] == 0 {
            charCount.removeValue(forKey: leftChar)
        }
        left += 1
    }
    
    // Обновляем максимальную длину и позицию начала
    let currentLength = right - left + 1
    if currentLength > maxLength {
        maxLength = currentLength
        bestStart = left
    }
}

print(maxLength, bestStart + 1) // Нумерация с 1
```

### 99. [Двоичный поиск](https://coderun.yandex.ru/problem/binary-search)


**Условие задачи:**
Реализуйте двоичный поиск в массиве

**Решение задачи:**

```swift
import Foundation

// Считываем размеры массивов
let nk = readLine()!.split(separator: " ").map { Int($0)! }
let n = nk[0] // Размер первого массива
let k = nk[1] // Размер второго массива

// Считываем первый массив
let firstArray = readLine()!.split(separator: " ").map { Int($0)! }

// Считываем второй массив
let secondArray = readLine()!.split(separator: " ").map { Int($0)! }

// Функция для бинарного поиска
func binarySearch(_ target: Int, in array: [Int]) -> Bool {
    var left = 0
    var right = array.count - 1
    
    while left <= right {
        let mid = (left + right) / 2
        
        if array[mid] == target {
            return true
        } else if array[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    
    return false
}

// Для каждого элемента второго массива проверяем наличие в первом
for target in secondArray {
    if binarySearch(target, in: firstArray) {
        print("YES")
    } else {
        print("NO")
    }
}
```

---


### 100. [Приближенный двоичный поиск](https://coderun.yandex.ru/problem/bpproximate-binary-search)

**Условие задачи:**
Для каждого из чисел второй последовательности найдите ближайшее к нему в первой.

**Решение задачи:**

```swift
import Foundation

// Считываем размеры массивов
let nk = readLine()!.split(separator: " ").map { Int($0)! }
let n = nk[0] // Размер первого массива
let k = nk[1] // Размер второго массива

// Считываем первый массив (отсортирован)
let firstArray = readLine()!.split(separator: " ").map { Int($0)! }

// Считываем второй массив
let secondArray = readLine()!.split(separator: " ").map { Int($0)! }

// Функция для бинарного поиска ближайшего элемента
func findClosest(_ target: Int, in array: [Int]) -> Int {
    var left = 0
    var right = array.count - 1
    
    // Если target меньше или равен первому элементу
    if target <= array[left] {
        return array[left]
    }
    
    // Если target больше или равен последнему элементу
    if target >= array[right] {
        return array[right]
    }
    
    // Бинарный поиск
    while left < right {
        let mid = (left + right) / 2
        
        if array[mid] == target {
            return array[mid]
        }
        
        if target < array[mid] {
            right = mid
        } else {
            left = mid + 1
        }
    }
    
    // Сравниваем два ближайших элемента
    let leftDiff = abs(array[left - 1] - target)
    let rightDiff = abs(array[left] - target)
    
    if leftDiff < rightDiff || (leftDiff == rightDiff && array[left - 1] < array[left]) {
        return array[left - 1]
    } else {
        return array[left]
    }
}

// Для каждого элемента второго массива находим ближайший в первом
for target in secondArray {
    let closest = findClosest(target, in: firstArray)
    print(closest)
}
```

---



### 101. [Дипломы](https://coderun.yandex.ru/problem/diplomas)


**Условие задачи:**
Когда Петя учился в школе, он часто участвовал в олимпиадах по информатике, математике и физике. Так как он был достаточно способным мальчиком и усердно учился, то на многих из этих олимпиад он получал дипломы. К окончанию школы у него накопилось n дипломов, причём, как оказалось, все они имели одинаковые размеры: w — в ширину и h — в высоту. Сейчас Петя учится в одном из лучших российских университетов и живёт в общежитии со своими одногруппниками. Он решил украсить свою комнату, повесив на одну из стен свои дипломы за школьные олимпиады. Так как к бетонной стене прикрепить дипломы достаточно трудно, то он решил купить специальную доску из пробкового дерева, чтобы прикрепить её к стене, а к ней — дипломы. Для того чтобы эта конструкция выглядела более красиво, Петя хочет, чтобы доска была квадратной и занимала как можно меньше места на стене. Каждый диплом должен быть размещён строго в прямоугольнике размером w на h. Дипломы запрещается поворачивать на 90 градусов. Прямоугольники, соответствующие различным дипломам, не должны иметь общих внутренних точек. Требуется написать программу, которая вычислит минимальный размер стороны доски, которая потребуется Пете для размещения всех своих дипломов.

**Решение задачи:**

```swift
import Foundation

// Считываем входные данные
let input = readLine()!.split(separator: " ").map { Int($0)! }
let n = input[0] // Количество дипломов
let w = input[1] // Ширина диплома
let h = input[2] // Высота диплома

// Если дипломов нет, доска не нужна
if n == 0 {
    print(0)
    exit(0)
}

// Бинарный поиск по размеру стороны квадратной доски
var left = max(w, h)
var right = max(w, h) * n

// Функция для проверки, помещаются ли все дипломы на доску со стороной size
func canPlace(_ size: Int) -> Bool {
    let rows = size / h // Количество рядов по высоте
    let cols = size / w // Количество колонок по ширине
    return rows * cols >= n
}

while left < right {
    let mid = (left + right) / 2
    if canPlace(mid) {
        right = mid
    } else {
        left = mid + 1
    }
}

print(left)
```

---




### 103. [Расстановка ноутбуков](https://coderun.yandex.ru/problem/arrangement-laptops)

**Условие задачи:**
В школе решили на один прямоугольный стол поставить два прямоугольных ноутбука. Ноутбуки нужно поставить так, чтобы их стороны были параллельны сторонам стола. Определите, какие размеры должен иметь стол, чтобы оба ноутбука на него поместились, а площадь стола была минимальна.

**Решение задачи:**

```swift
let input = readLine()!.split(separator: " ").map { Int($0)! }
let a = input[0], b = input[1], c = input[2], d = input[3]

// Все возможные варианты расположения
let variants = [
    (a + c, max(b, d)),           // ноутбуки в ряд по горизонтали
    (max(a, c), b + d),           // ноутбуки в ряд по вертикали
    (a + d, max(b, c)),           // первый горизонтально, второй вертикально
    (max(a, d), b + c)            // первый вертикально, второй горизонтально
]

let minVariant = variants.min { $0.0 * $0.1 < $1.0 * $1.1 }!
print(minVariant.0, minVariant.1)
```

---

### 106. [Провода](https://coderun.yandex.ru/problem/wires)
**Условие задачи:**
Дано N отрезков провода. Нужно получить K равных отрезков максимальной целой длины путем разрезания исходных отрезков.

**Идея решения:**
Это задача на бинарный поиск по ответу. Мы ищем максимальную длину отрезка, которую можно получить. 
- Минимальная возможная длина = 0 (если невозможно)
- Максимальная возможная длина = максимальный из исходных отрезков
- Для каждой длины проверяем, можно ли получить K отрезков такой длины

**Решение задачи:**

```swift
import Foundation

// Функция для проверки, можно ли получить K отрезков длиной cutLength
func canCut(_ wires: [Int], _ k: Int, _ cutLength: Int) -> Bool {
    if cutLength == 0 { return true } // можно получить сколько угодно отрезков длиной 0
    
    var count = 0
    for wire in wires {
        count += wire / cutLength
        if count >= k { return true } // оптимизация: не считаем дальше если уже достаточно
    }
    return false
}

// Чтение входных данных
let firstLine = readLine()!.split(separator: " ").map { Int($0)! }
let n = firstLine[0]
let k = firstLine[1]

var wires: [Int] = []
for _ in 0..<n {
    wires.append(Int(readLine()!)!)
}

// Бинарный поиск по длине отрезка
var left = 0
var right = wires.max()!
var result = 0

while left <= right {
    let mid = (left + right) / 2
    
    if canCut(wires, k, mid) {
        result = mid
        left = mid + 1  // пробуем найти большую длину
    } else {
        right = mid - 1 // уменьшаем длину
    }
}

print(result)
```

### 108. [Медиана объединения](https://coderun.yandex.ru/problem/median-union)
Понял 👍 Давай я оформлю в таком же шаблоне, как у тебя.

---

**Условие задачи:**
Дано $N$ упорядоченных по неубыванию последовательностей целых чисел, в каждой из которых ровно $L$ элементов.
Для каждой пары последовательностей необходимо найти **левую медиану** объединения (т.е. элемент на позиции $L$ в отсортированной последовательности длиной $2L$).


**Оценка сложности:**
* Общая сложность: $O(N^2 \cdot L)$, что даёт максимум ≈ $100^2 \cdot 300 = 3 \cdot 10^6$ операций → **нормально по времени**.
* Память: храним все массивы $N \cdot L \leq 30\,000$ элементов → **нормально по памяти**.

---

**Решение задачи:**

```swift
import Foundation

let firstLine = readLine()!.split(separator: " ").map { Int($0)! }
let N = firstLine[0]
let L = firstLine[1]

// Читаем все последовательности
var sequences: [[Int]] = []
for _ in 0..<N {
    let seq = readLine()!.split(separator: " ").map { Int($0)! }
    sequences.append(seq)
}

// Функция нахождения медианы объединения двух отсортированных массивов
func medianOfTwo(_ a: [Int], _ b: [Int], L: Int) -> Int {
    var i = 0, j = 0, count = 0
    var last = 0
    
    // идём по слиянию, пока не дойдём до L-го элемента
    while count < L {
        if j >= L || (i < L && a[i] <= b[j]) {
            last = a[i]
            i += 1
        } else {
            last = b[j]
            j += 1
        }
        count += 1
    }
    return last
}

// Перебираем все пары
for i in 0..<N {
    for j in (i+1)..<N {
        let med = medianOfTwo(sequences[i], sequences[j], L: L)
        print(med)
    }
}
```

---



### 114. [Кассы](https://coderun.yandex.ru/problem/cash-registers)

**Условие задачи:**
На вокзале работает $N$ касс, каждая по фиксированному расписанию в течение суток. Нужно определить, сколько минут в сутки **все кассы одновременно работают**.

Условия:

* $0 < N \leq 1000$
* Время задаётся в часах и минутах (0–23, 0–59).
* Время открытия включительно, время закрытия не включительно.
* Если открытие == закрытию → касса работает круглосуточно.
* Если открытие позже закрытия → работа "через полночь".

---

**Идея решения:**

1. Всего в сутках 1440 минут.
2. Для каждой кассы отмечаем все минуты её работы в массиве `Bool` длиной 1440.
3. Пересекаем графики всех касс (побитовое И).
4. Подсчитываем количество `true` в результирующем массиве.

---

**Оценка сложности:**

* Время: $O(N \cdot 1440)$, максимум ≈ 1.44 млн операций (нормально).
* Память: $O(1440)$ на рабочий массив + временный массив под кассу.

---

**Решение задачи:**

```swift
import Foundation

let N = Int(readLine()!)!

let MINUTES_IN_DAY = 24 * 60

// Все кассы должны работать одновременно -> начнем с массива, где все true
var allOpen = Array(repeating: true, count: MINUTES_IN_DAY)

for _ in 0..<N {
    let parts = readLine()!.split(separator: " ").map { Int($0)! }
    let openH = parts[0], openM = parts[1], closeH = parts[2], closeM = parts[3]
    
    let openTime = openH * 60 + openM
    let closeTime = closeH * 60 + closeM
    
    var schedule = Array(repeating: false, count: MINUTES_IN_DAY)
    
    if openTime == closeTime {
        // Круглосуточно
        schedule = Array(repeating: true, count: MINUTES_IN_DAY)
    } else if openTime < closeTime {
        // Работает в пределах суток
        for t in openTime..<closeTime {
            schedule[t] = true
        }
    } else {
        // Работает через полночь
        for t in openTime..<MINUTES_IN_DAY {
            schedule[t] = true
        }
        for t in 0..<closeTime {
            schedule[t] = true
        }
    }
    
    // Пересекаем с общим графиком
    for i in 0..<MINUTES_IN_DAY {
        allOpen[i] = allOpen[i] && schedule[i]
    }
}

// Считаем минуты, когда все кассы открыты
let result = allOpen.filter { $0 }.count
print(result)
```


### 120. [Высота дерева](https://coderun.yandex.ru/problem/tree-height)

**Условие задачи:**
Реализовать бинарное дерево поиска (BST) для целых чисел.
Элементы добавляются последовательно, без балансировки (первый элемент — корень).
Нужно найти **высоту дерева**.

* Последовательность натуральных чисел оканчивается `0`.
* `0` в дерево не добавляется.
* Высота дерева — максимальное количество вершин на пути от корня до листа.

---

**Идея решения:**

1. Создать структуру узла дерева: значение, левый и правый ребёнок.
2. Последовательно добавлять числа:

   * если ≤ текущего узла → влево,
   * если > → вправо.
3. После построения вычислить высоту рекурсией:

   ```
   height(node) = 0, если node == nil  
   иначе = 1 + max(height(left), height(right))
   ```

---

**Оценка сложности:**

* Вставка одного элемента: $O(h)$, где $h$ — высота дерева.
* В худшем случае (отсортированная последовательность) $h = n$.
* Общая сложность: $O(n^2)$ в худшем, $O(n \log n)$ в среднем.
* Память: $O(n)$.

---

**Решение задачи (Swift):**

```swift
import Foundation

class Node {
    var value: Int
    var left: Node?
    var right: Node?
    
    init(_ value: Int) {
        self.value = value
    }
    
    // вставка нового значения
    func insert(_ newValue: Int) {
        if newValue <= value {
            if let l = left {
                l.insert(newValue)
            } else {
                left = Node(newValue)
            }
        } else {
            if let r = right {
                r.insert(newValue)
            } else {
                right = Node(newValue)
            }
        }
    }
}

// функция для вычисления высоты дерева
func height(_ node: Node?) -> Int {
    guard let n = node else { return 0 }
    return 1 + max(height(n.left), height(n.right))
}

// читаем последовательность и строим дерево
var root: Node? = nil

while let line = readLine(), let num = Int(line), num != 0 {
    if root == nil {
        root = Node(num)
    } else {
        root!.insert(num)
    }
}

// выводим высоту дерева
print(height(root))
```


### 121. [Глубина добавляемых элементов](https://coderun.yandex.ru/problem/depth-added-elements)

**Условие задачи:**
В бинарное дерево поиска (BST) последовательно добавляются элементы. Для каждого **нового** элемента нужно вывести его глубину (расстояние от корня до этого элемента, включая корень).

* Если элемент уже есть в дереве, то он **не добавляется** и глубина **не выводится**.
* Последовательность оканчивается числом `0`, оно не добавляется.

---

**Идея решения:**

1. Реализуем класс узла BST.
2. При добавлении нового значения:

   * если оно равно текущему узлу → ничего не делаем;
   * если меньше → идём влево;
   * если больше → идём вправо.
3. При успешной вставке возвращаем глубину вставленного узла.
4. Печатаем глубину сразу при вставке.

---

**Оценка сложности:**

* Вставка: $O(h)$, где $h$ — высота дерева.
* Память: $O(n)$ на хранение всех узлов.

---

**Решение задачи (Swift):**

```swift
import Foundation

class Node {
    var value: Int
    var left: Node?
    var right: Node?
    
    init(_ value: Int) {
        self.value = value
    }
    
    // Вставка с возвратом глубины
    func insert(_ newValue: Int, depth: Int) -> Int? {
        if newValue == value {
            return nil  // уже есть, не добавляем
        } else if newValue < value {
            if let l = left {
                return l.insert(newValue, depth: depth + 1)
            } else {
                left = Node(newValue)
                return depth + 1
            }
        } else {
            if let r = right {
                return r.insert(newValue, depth: depth + 1)
            } else {
                right = Node(newValue)
                return depth + 1
            }
        }
    }
}

var root: Node? = nil

while let line = readLine(), let num = Int(line), num != 0 {
    if root == nil {
        root = Node(num)
        print(1)  // корень всегда глубина 1
    } else {
        if let d = root!.insert(num, depth: 1) {
            print(d)
        }
    }
}
```


### 124. [Вывод листьев](https://coderun.yandex.ru/problem/leaf-conclusion)
**Условие задачи:**
Для бинарного дерева поиска, построенного на заданных числах, требуется вывести список всех листьев (вершин, не имеющих потомков) в порядке возрастания. Элементы добавляются в дерево последовательно, балансировки не происходит (первый элемент последовательности — корень).

---

**Идея решения:**

1. Реализовать структуру узла BST.
2. Построить дерево по входной последовательности (оканчивается нулём).
3. Рекурсивно обойти дерево и найти листья (узлы без левого и правого ребёнка).
4. Собрать листья в массив, отсортировать и вывести.

---

**Оценка сложности:**

* Построение дерева: $O(n \cdot h)$, где $h$ — высота (в худшем случае $O(n^2)$).
* Поиск листьев: $O(n)$.
* Сортировка листьев: $O(k \log k)$, где $k$ — количество листьев.
* Память: $O(n)$.

---

**Решение задачи:**

```swift
import Foundation

class Node {
    var value: Int
    var left: Node?
    var right: Node?
    
    init(_ value: Int) {
        self.value = value
    }
    
    func insert(_ newValue: Int) {
        if newValue <= value {
            if let l = left {
                l.insert(newValue)
            } else {
                left = Node(newValue)
            }
        } else {
            if let r = right {
                r.insert(newValue)
            } else {
                right = Node(newValue)
            }
        }
    }
}

func collectLeaves(_ node: Node?, _ result: inout [Int]) {
    guard let n = node else { return }
    if n.left == nil && n.right == nil {
        result.append(n.value)
    } else {
        collectLeaves(n.left, &result)
        collectLeaves(n.right, &result)
    }
}

var root: Node? = nil

while let line = readLine(), let num = Int(line), num != 0 {
    if root == nil {
        root = Node(num)
    } else {
        root!.insert(num)
    }
}

var leaves: [Int] = []
collectLeaves(root, &leaves)
leaves.sort()

print(leaves.map { String($0) }.joined(separator: " "))
```


### 125. [Вывод развилок](https://coderun.yandex.ru/problem/fork-conclusion)
**Условие задачи:**
Построить бинарное дерево поиска (BST) по заданной последовательности чисел (завершающейся нулём, который не входит в дерево).
Нужно вывести список всех вершин, у которых есть **оба ребёнка** (левый и правый). Выводить в порядке возрастания.

---

**Идея решения:**

1. Реализуем структуру узла BST.
2. Построим дерево, добавляя элементы последовательно.
3. Обойдём дерево рекурсивно, собирая вершины, у которых есть и левый, и правый ребёнок.
4. Отсортируем список и выведем.

---

**Оценка сложности:**

* Построение дерева: $O(n \cdot h)$, где $h$ — высота (в худшем $O(n^2)$).
* Поиск нужных вершин: $O(n)$.
* Сортировка ответа: $O(k \log k)$, где $k$ — количество найденных вершин.
* Память: $O(n)$.

---

**Решение задачи:**

```swift
import Foundation

class Node {
    var value: Int
    var left: Node?
    var right: Node?
    
    init(_ value: Int) {
        self.value = value
    }
    
    func insert(_ newValue: Int) {
        if newValue <= value {
            if let l = left {
                l.insert(newValue)
            } else {
                left = Node(newValue)
            }
        } else {
            if let r = right {
                r.insert(newValue)
            } else {
                right = Node(newValue)
            }
        }
    }
}

func collectTwoChildren(_ node: Node?, _ result: inout [Int]) {
    guard let n = node else { return }
    if n.left != nil && n.right != nil {
        result.append(n.value)
    }
    collectTwoChildren(n.left, &result)
    collectTwoChildren(n.right, &result)
}

var root: Node? = nil

while let line = readLine(), let num = Int(line), num != 0 {
    if root == nil {
        root = Node(num)
    } else {
        root!.insert(num)
    }
}

var nodes: [Int] = []
collectTwoChildren(root, &nodes)
nodes.sort()

print(nodes.map { String($0) }.joined(separator: " "))
```


### 126. [Вывод веток](https://coderun.yandex.ru/problem/branches-conclusion)
**Условие задачи:**
Построить бинарное дерево поиска (BST) по заданной последовательности чисел, завершающейся нулём (ноль не входит в дерево).
Нужно вывести список всех вершин, у которых есть **ровно один ребёнок** (левый или правый, но не оба).
Вывести значения этих вершин в порядке возрастания.

---

**Идея решения:**

1. Реализовать структуру узла BST.
2. При построении не добавлять дубликаты (по определению BST в задаче).
3. Обойти дерево и собрать вершины, у которых ровно один ребёнок.
4. Отсортировать и вывести.

---

**Оценка сложности:**

* Построение дерева: $O(n \cdot h)$, где $h$ — высота дерева (худший случай $O(n^2)$).
* Поиск узлов: $O(n)$.
* Сортировка ответа: $O(k \log k)$, где $k$ — количество найденных вершин.
* Память: $O(n)$.

---

**Решение задачи (Swift):**

```swift
import Foundation

class Node {
    var value: Int
    var left: Node?
    var right: Node?
    
    init(_ value: Int) {
        self.value = value
    }
    
    func insert(_ newValue: Int) {
        if newValue < value {
            if let l = left {
                l.insert(newValue)
            } else {
                left = Node(newValue)
            }
        } else if newValue > value {
            if let r = right {
                r.insert(newValue)
            } else {
                right = Node(newValue)
            }
        }
        // равные игнорируются (дубликаты не вставляем)
    }
}

func collectOneChild(_ node: Node?, _ result: inout [Int]) {
    guard let n = node else { return }
    if (n.left == nil && n.right != nil) || (n.left != nil && n.right == nil) {
        result.append(n.value)
    }
    collectOneChild(n.left, &result)
    collectOneChild(n.right, &result)
}

var root: Node? = nil

while let line = readLine(), let num = Int(line), num != 0 {
    if root == nil {
        root = Node(num)
    } else {
        root!.insert(num)
    }
}

var nodes: [Int] = []
collectOneChild(root, &nodes)
nodes.sort()

print(nodes.map { String($0) }.joined(separator: " "))
```

---


### 127. [АВЛ-сбалансированность](https://coderun.yandex.ru/problem/avl-balance)

**Условие задачи:**

* Ввод: последовательность целых чисел, оканчивающаяся нулём (ноль **не входит** в дерево).
* Нужно построить **бинарное дерево поиска** (каждое число вставляется по правилам БДП).
* Проверить, является ли оно **АВЛ-сбалансированным**.
* Вывести:

  * `YES`, если дерево сбалансировано;
  * `NO`, если нет.

---

**Решение задачи (Swift):**

```swift
import Foundation

// Узел дерева
class Node {
    var value: Int
    var left: Node?
    var right: Node?
    
    init(_ value: Int) {
        self.value = value
    }
}

// Вставка в бинарное дерево поиска
func insert(_ root: inout Node?, _ value: Int) {
    if root == nil {
        root = Node(value)
    } else if value < root!.value {
        insert(&root!.left, value)
    } else if value > root!.value {
        insert(&root!.right, value)
    }
}

// Проверка сбалансированности (возвращает высоту или -1 если несбалансировано)
func checkHeight(_ node: Node?) -> Int {
    guard let node = node else { return 0 }
    
    let leftHeight = checkHeight(node.left)
    if leftHeight == -1 { return -1 }
    
    let rightHeight = checkHeight(node.right)
    if rightHeight == -1 { return -1 }
    
    if abs(leftHeight - rightHeight) > 1 {
        return -1
    }
    
    return max(leftHeight, rightHeight) + 1
}

// Основная программа
var root: Node? = nil
let input = readLine()!.split(separator: " ").map { Int($0)! }

for value in input where value != 0 {
    insert(&root, value)
}

print(checkHeight(root) == -1 ? "NO" : "YES")
```

### 129. [Родословная: подсчет уровней](https://coderun.yandex.ru/problem/pedigree-counting-levels)
**Условие задачи:**
В генеалогическом древе каждый человек, кроме родоначальника, имеет ровно одного родителя.
Каждому элементу дерева сопоставляется целое неотрицательное число — **высота**:

* родоначальник: 0
* любой другой: на 1 больше, чем у родителя

Нужно определить высоту всех элементов.
Вывести элементы в **лексикографическом порядке** с их высотой.

---

**Решение задачи:**

```swift
import Foundation

let N = Int(readLine()!)!

var parent: [String: String] = [:]
var nodes: Set<String> = []

for _ in 0..<(N-1) {
    let parts = readLine()!.split(separator: " ").map { String($0) }
    let child = parts[0], par = parts[1]
    parent[child] = par
    nodes.insert(child)
    nodes.insert(par)
}

// Находим родоначальника
let root = nodes.first { !parent.keys.contains($0) }!

var height: [String: Int] = [:]
height[root] = 0

func getHeight(_ name: String) -> Int {
    if let h = height[name] { return h }
    let h = getHeight(parent[name]!) + 1
    height[name] = h
    return h
}

for name in nodes {
    _ = getHeight(name)
}

let sortedNames = nodes.sorted()
for name in sortedNames {
    print("\(name) \(height[name]!)")
}
```


### 130. [Гистограмма](https://coderun.yandex.ru/problem/histogram)
**Условие задачи:**
Необходимо построить гистограмму количества каждого символа в зашифрованном тексте, исключая пробелы и переводы строк.
Гистограмма должна отображать символ `#` для каждого вхождения символа, а под каждым столбиком — сам символ.
Столбики выводятся **без пробелов между ними**, отсортированы по возрастанию кодов символов.

---

**Идея решения:**

1. Считать весь текст и подсчитать количество каждого символа, кроме пробелов и переводов строк.
2. Отсортировать символы по их кодам.
3. Найти максимальное количество вхождений, чтобы определить высоту гистограммы.
4. Выводить гистограмму построчно сверху вниз, печатая `#` там, где высота столбика достигает соответствующего уровня, иначе пробел.
5. В последней строке вывести символы под столбиками.

---

**Оценка сложности:**

* Время: $O(L + K \cdot H)$, где $L \le 10000$ — длина текста, $K$ — количество различных символов, $H$ — максимальное число повторений символа.
* Память: $O(K)$ для подсчёта символов.

---

**Решение задачи (Swift):**

```swift
import Foundation

var counts: [Character: Int] = [:]

while let line = readLine() {
    for ch in line {
        if ch != " " && ch != "\n" {
            counts[ch, default: 0] += 1
        }
    }
}

// Сортировка символов по коду
let symbols = counts.keys.sorted { $0.asciiValue! < $1.asciiValue! }

// Максимальная высота столбика
let maxCount = counts.values.max()!

for level in stride(from: maxCount, through: 1, by: -1) {
    for sym in symbols {
        if counts[sym]! >= level {
            print("#", terminator: "")
        } else {
            print(" ", terminator: "")
        }
    }
    print()
}

// Последняя строка — сами символы
for sym in symbols {
    print(sym, terminator: "")
}
print()
```


### 132. [Коллекционер Диего](https://coderun.yandex.ru/problem/collector-diego)
**Условие задачи:**
Диего имеет N наклеек с номерами (возможно, повторяющиеся). K коллекционеров хотят узнать, сколько **уникальных наклеек** Диего им недостаёт, если каждый коллекционер уже имеет все наклейки с номерами ≥ pᵢ.

---

**Идея решения:**

1. Создать множество уникальных номеров наклеек Диего.
2. Отсортировать уникальные номера для быстрого поиска.
3. Для каждого pᵢ найти индекс первого числа ≥ pᵢ (например, через бинарный поиск).
4. Количество недостающих уникальных наклеек = количество уникальных наклеек с номерами < pᵢ.

---

**Оценка сложности:**

* Формирование множества и сортировка: $O(N \log N)$
* Поиск для K коллекционеров: $O(K \log N)$
* Память: $O(N)$ для хранения уникальных номеров.

---

**Решение задачи (Swift):**

```swift
import Foundation

let N = Int(readLine()!)!
let stickers = readLine()!.split(separator: " ").map { Int($0)! }

let uniqueStickers = Array(Set(stickers)).sorted() // уникальные и отсортированные

let K = Int(readLine()!)!
let collectors = readLine()!.split(separator: " ").map { Int($0)! }

// бинарный поиск для нахождения количества элементов < p
func countLessThan(_ p: Int) -> Int {
    var left = 0, right = uniqueStickers.count
    while left < right {
        let mid = (left + right) / 2
        if uniqueStickers[mid] < p {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return left
}

for p in collectors {
    print(countLessThan(p))
}
```


### 134. [Хорошая строка](https://coderun.yandex.ru/problem/good-line)

Понял, вы хотите, чтобы я строго следовал шаблону и не перефразировал условие. Давайте полностью по шаблону:

---

**Условие задачи:**
На день рождения маленький Ипполит получил долгожданный подарок — набор дощечек с написанными на них буквами латинского алфавита. Теперь-то он будет чем заняться долгими вечерами, тем более что мама обещала подарить ему в следующем году последовательность целых неотрицательных чисел, если он хорошо освоит этот набор. Ради такого богатства Ипполит готов на многое.

Прямо сейчас юный исследователь полностью поглощён изучением хорошести строк. Хорошестью строки называется количество позиций от 1 до L - 1 (где L — длина строки), таких, что следующая буква в строке является следующей по алфавиту. Например, хорошесть строки "abcdefghijklmnopqrstuvwxyz" равна 25, а строки "abdc" — только 1.

Ипполит размышляет над решением закономерно возникающей задачи: чему равна максимально возможная хорошесть строки, которую можно собрать, используя дощечки из данного набора.

Формат ввода
Первая строка ввода содержит единственное целое число N — количество различных букв в наборе (1 ≤ N ≤ 26). Обратите внимание: в наборе всегда используются N первых букв латинского алфавита.

Следующие N строк содержат целые положительные числа c\_i — количество букв соответствующего типа (1 ≤ c\_i ≤ 10^9). Таким образом, первое число означает количество букв "a", второе число задаёт количество букв "b" и так далее.

Формат вывода
Выведите единственное целое число — максимально возможную хорошесть строки, которую можно собрать из имеющихся дощечек.

---

**Идея решения:**
Для максимальной хорошести строки буквы необходимо расположить в алфавитном порядке. Каждая последовательная пара букв, идущих по алфавиту, увеличивает хорошесть на 1. Поскольку каждая буква может повторяться, максимальная хорошесть равна сумме всех букв минус 1 (так как последняя буква в последовательности не увеличивает хорошесть).

---

**Оценка сложности:**

* Время: O(N), где N ≤ 26
* Память: O(N)

---

**Решение задачи (Swift):**

```swift
import Foundation

let N = Int(readLine()!)!
var counts: [Int] = []

for _ in 0..<N {
    counts.append(Int(readLine()!)!)
}

let totalLetters = counts.reduce(0, +)
let maxGoodness = totalLetters - 1
print(maxGoodness)
```


### 135. [Операционные системы lite](https://coderun.yandex.ru/problem/lite-operating-systems)

**Условие задачи:**
Васин жесткий диск состоит из M секторов. Вася создавал N разделов на диске, каждый из которых может полностью или частично стирать предыдущие разделы. Определить, сколько разделов остались работоспособными.

---

**Идея решения:**

1. Разделы можно представить как интервалы `[a_i, b_i]`.
2. Если новый раздел пересекается с предыдущими, пересечённые старые разделы теряют работоспособность.
3. Проходим по разделам в порядке создания, для каждого нового проверяем пересечения со всеми предыдущими "живыми" разделами, удаляя пересечённые.
4. В конце количество оставшихся "живых" разделов — ответ.

---

**Оценка сложности:**

* Время: O(N²) (поскольку N ≤ 1000, это допустимо)
* Память: O(N) для хранения активных разделов

---

**Решение задачи (Swift):**

```swift
import Foundation

let firstLine = readLine()!.split(separator: " ").map { Int($0)! }
let M = firstLine[0]
let N = firstLine[1]

var intervals: [(Int, Int)] = []

for _ in 0..<N {
    let ab = readLine()!.split(separator: " ").map { Int($0)! }
    let a = ab[0], b = ab[1]
    // удаляем все пересекающиеся с новым интервалом
    intervals = intervals.filter { $0.1 < a || $0.0 > b }
    intervals.append((a,b))
}

print(intervals.count)
```



### 137. [Минимальный прямоугольник](https://coderun.yandex.ru/problem/minimum-rectangle)
**Условие задачи:**
На клетчатой плоскости закрашено K клеток. Найти минимальный по площади прямоугольник с осями, параллельными сетке, покрывающий все закрашенные клетки.

---

**Идея решения:**

1. Для минимального прямоугольника нужно найти минимальные и максимальные значения координат X и Y среди всех закрашенных клеток.
2. Левый нижний угол: `(minX, minY)`, правый верхний угол: `(maxX, maxY)`.

---

**Оценка сложности:**

* Время: O(K)
* Память: O(1)

---

**Решение задачи (Swift):**

```swift
import Foundation

let K = Int(readLine()!)!
var minX = Int.max, minY = Int.max
var maxX = Int.min, maxY = Int.min

for _ in 0..<K {
    let xy = readLine()!.split(separator: " ").map { Int($0)! }
    let x = xy[0], y = xy[1]
    minX = min(minX, x)
    minY = min(minY, y)
    maxX = max(maxX, x)
    maxY = max(maxY, y)
}

print("\(minX) \(minY) \(maxX) \(maxY)")
```

### 138. [Сумма в прямоугольнике](https://coderun.yandex.ru/problem/rectangle-sum)
**Условие задачи:**
Вам необходимо ответить на запросы — узнать сумму всех элементов числовой матрицы N×M в прямоугольнике с левым верхним углом (x₁, y₁) и правым нижним (x₂, y₂).

---

**Идея решения:**

1. Построить префиксную сумму `prefix[i][j]` — сумма элементов матрицы в прямоугольнике от (1,1) до (i,j).
2. Для запроса `(x1, y1, x2, y2)` сумма вычисляется за O(1):

   ```
   sum = prefix[x2][y2] - prefix[x1-1][y2] - prefix[x2][y1-1] + prefix[x1-1][y1-1]
   ```
3. Используем 1-индексацию для удобства.

---

**Оценка сложности:**

* Время: O(N\*M + K)
* Память: O(N\*M) для префиксной суммы

---

**Решение задачи (Swift):**

```swift
import Foundation

let firstLine = readLine()!.split(separator: " ").map { Int($0)! }
let N = firstLine[0], M = firstLine[1], K = firstLine[2]

var mat = [[Int]](repeating: [Int](repeating: 0, count: M+1), count: N+1)
var prefix = [[Int]](repeating: [Int](repeating: 0, count: M+1), count: N+1)

// чтение матрицы и построение префиксной суммы
for i in 1...N {
    let row = readLine()!.split(separator: " ").map { Int($0)! }
    for j in 1...M {
        mat[i][j] = row[j-1]
        prefix[i][j] = mat[i][j] + prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1]
    }
}

// обработка запросов
for _ in 0..<K {
    let q = readLine()!.split(separator: " ").map { Int($0)! }
    let x1 = q[0], y1 = q[1], x2 = q[2], y2 = q[3]
    let sum = prefix[x2][y2] - prefix[x1-1][y2] - prefix[x2][y1-1] + prefix[x1-1][y1-1]
    print(sum)
}
```

### 139. [Скучная лекция](https://coderun.yandex.ru/problem/boring-lecture)
**Условие задачи:**
Лёша выписывает все возможные подстроки своего любимого слова, обрезая любое количество букв с начала и конца. Нужно посчитать, сколько раз каждая буква встречается среди всех этих подстрок.

---

**Идея решения:**

1. Заметим, что каждая буква на позиции `i` в слове длины `n` встречается в подстроках `(i+1) * (n-i)` раз.

   * `i+1` — количество вариантов выбора начала подстроки, чтобы включить букву на позиции `i`.
   * `n-i` — количество вариантов выбора конца подстроки, чтобы включить букву на позиции `i`.
2. Проходим по слову и суммируем эти количества для каждой буквы.
3. Выводим буквы в алфавитном порядке.

---

**Оценка сложности:**

* Время: O(N)
* Память: O(1) для массива счётчиков (фиксированное количество букв латинского алфавита)

---

**Решение задачи (Swift):**

```swift
import Foundation

let s = readLine()!
let n = s.count
var counts = [Character: Int]()

for (i, ch) in s.enumerated() {
    counts[ch, default: 0] += (i + 1) * (n - i)
}

for ch in counts.keys.sorted() {
    print("\(ch): \(counts[ch]!)")
}
```

### 140. [Стек с защитой от ошибок](https://coderun.yandex.ru/problem/stack-protection-from-errors)
**Условие задачи:**
Научитесь пользоваться стандартной структурой данных stack для целых чисел. Реализуйте все команды, выводя результат после каждой.

---

**Идея решения:**

1. Используем массив `[Int]` как стек.
2. `push n` → добавляем элемент в конец массива.
3. `pop` → удаляем и выводим последний элемент, проверяя пустоту.
4. `back` → выводим последний элемент без удаления, проверяя пустоту.
5. `size` → выводим длину массива.
6. `clear` → очищаем массив.
7. `exit` → выводим `bye` и завершаем программу.

---

**Оценка сложности:**

* Время: O(1) на каждую команду
* Память: O(N), где N — текущее количество элементов

---

**Решение задачи (Swift):**

```swift
import Foundation

var stack: [Int] = []

while let line = readLine() {
    let parts = line.split(separator: " ")
    let command = parts[0]

    switch command {
    case "push":
        let n = Int(parts[1])!
        stack.append(n)
        print("ok")
    case "pop":
        if stack.isEmpty {
            print("error")
        } else {
            print(stack.removeLast())
        }
    case "back":
        if stack.isEmpty {
            print("error")
        } else {
            print(stack.last!)
        }
    case "size":
        print(stack.count)
    case "clear":
        stack.removeAll()
        print("ok")
    case "exit":
        print("bye")
        exit(0)
    default:
        break
    }
}
```

### 141. [Правильная скобочная последовательность](https://coderun.yandex.ru/problem/correct-bracket-sequence)
**Условие задачи:**
Рассмотрим последовательность, состоящую из круглых, квадратных и фигурных скобок. Программа дожна определить, является ли данная скобочная последовательность правильной.

---

**Идея решения:**

1. Используем стек для открывающих скобок.
2. Проходим по символам строки:

   * Если открывающая скобка `(`, `[`, `{` → помещаем в стек.
   * Если закрывающая `)`, `]`, `}` → проверяем верх стека: если соответствует открывающей, извлекаем; иначе последовательность неправильная.
3. После обработки строка правильная, если стек пуст.

---

**Оценка сложности:**

* Время: O(N), где N — длина последовательности
* Память: O(N) для стека

---

**Решение задачи (Swift):**

```swift
import Foundation

let s = readLine()!
var stack: [Character] = []
var correct = true

for ch in s {
    if ch == "(" || ch == "[" || ch == "{" {
        stack.append(ch)
    } else {
        if stack.isEmpty {
            correct = false
            break
        }
        let last = stack.removeLast()
        if (ch == ")" && last != "(") ||
           (ch == "]" && last != "[") ||
           (ch == "}" && last != "{") {
            correct = false
            break
        }
    }
}

print(correct && stack.isEmpty ? "yes" : "no")
```

### 142. [Постфиксная запись](https://coderun.yandex.ru/problem/postfix-entry)

**Условие задачи:**
В постфиксной записи (или обратной польской записи) операция записывается после двух операндов. Например, сумма двух чисел A и B записывается как A B +. Запись B C + D \* обозначает привычное нам (B + C) \* D, а запись A B C + D \* + означает A + (B + C) \* D. Достоинство постфиксной записи в том, что она не требует скобок и дополнительных соглашений о приоритете операторов для своего чтения.

---

**Идея решения:**

1. Используем стек для чисел.
2. Проходим по каждому элементу выражения:

   * Если элемент — число, помещаем в стек.
   * Если элемент — операция, извлекаем два верхних числа из стека, выполняем операцию и кладём результат обратно.
3. После обработки всех элементов стек содержит одно число — результат.

---

**Оценка сложности:**

* Время: O(N), где N — количество токенов в выражении
* Память: O(N) для стека

---

**Решение задачи (Swift):**

```swift
import Foundation

let tokens = readLine()!.split(separator: " ").map { String($0) }
var stack: [Int] = []

for token in tokens {
    if let num = Int(token) {
        stack.append(num)
    } else {
        let b = stack.removeLast()
        let a = stack.removeLast()
        switch token {
        case "+": stack.append(a + b)
        case "-": stack.append(a - b)
        case "*": stack.append(a * b)
        default: break
        }
    }
}

print(stack.last!)
```

### 144. [Великое Лайнландское переселение](https://coderun.yandex.ru/problem/great-lineland-migration)
**Условие задачи:**
Лайнландия представляет из себя одномерный мир, являющийся прямой, на котором располагаются N городов, последовательно пронумерованных от 0 до N - 1. Жители каждого города движутся на восток до первого города с меньшей ценой проживания. Если такого города нет, выводится -1.

---

**Идея решения:**
Используем **монотонный стек**:

1. Проходим города слева направо (от 0 к N-1).
2. Для каждого города поддерживаем стек индексов городов с невозрастающими ценами.
3. Если цена следующего города меньше цены города из стека, жители города из стека переселяются туда.
4. В противном случае, продолжаем добавлять город в стек.
5. В конце все оставшиеся города в стеке получают -1.

---

**Оценка сложности:**

* Время: O(N) — каждый город один раз добавляется и удаляется из стека.
* Память: O(N) для стека и массива результата.

---

**Решение задачи (Swift):**

```swift
import Foundation

let N = Int(readLine()!)!
let prices = readLine()!.split(separator: " ").map { Int($0)! }

var result = Array(repeating: -1, count: N)
var stack: [Int] = []

for i in 0..<N {
    while let last = stack.last, prices[i] < prices[last] {
        result[stack.removeLast()] = i
    }
    stack.append(i)
}

print(result.map { String($0) }.joined(separator: " "))
```

### 145. [Очередь с защитой от ошибок](https://coderun.yandex.ru/problem/queue-with-error-protection)
**Условие задачи:**
Научитесь пользоваться стандартной структурой данных queue для целых чисел. Напишите программу, содержащую описание очереди и моделирующую работу очереди, реализовав все указанные здесь методы.

---

**Идея решения:**

1. Используем массив `[Int]` для хранения элементов очереди.
2. `push n` → добавляем элемент в конец массива.
3. `pop` → удаляем и выводим первый элемент, проверяя на пустоту.
4. `front` → выводим первый элемент без удаления, проверяя на пустоту.
5. `size` → выводим длину массива.
6. `clear` → очищаем массив.
7. `exit` → выводим `bye` и завершаем программу.

---

**Оценка сложности:**

* Время: `push` и `pop` — O(1) амортизированно (для небольшого N можно считать O(1)), `front` и `size` — O(1)
* Память: O(N), где N — текущее количество элементов очереди

---

**Решение задачи (Swift):**

```swift
import Foundation

var queue: [Int] = []

while let line = readLine() {
    let parts = line.split(separator: " ")
    let command = parts[0]

    switch command {
    case "push":
        let n = Int(parts[1])!
        queue.append(n)
        print("ok")
    case "pop":
        if queue.isEmpty {
            print("error")
        } else {
            print(queue.removeFirst())
        }
    case "front":
        if queue.isEmpty {
            print("error")
        } else {
            print(queue.first!)
        }
    case "size":
        print(queue.count)
    case "clear":
        queue.removeAll()
        print("ok")
    case "exit":
        print("bye")
        exit(0)
    default:
        break
    }
}
```

### 146. [Игра в пьяницу](https://coderun.yandex.ru/problem/drunkard-game)
**Условие задачи:**
В игре в пьяницу карточная колода раздается поровну двум игрокам. Далее они вскрывают по одной верхней карте, и тот, чья карта старше, забирает себе обе вскрытые карты, которые кладутся под низ его колоды. Тот, кто остается без карт – проигрывает. Для простоты будем считать, что все карты различны по номиналу, а также, что самая младшая карта побеждает самую старшую карту («шестерка берет туза»). Игрок, который забирает себе карты, сначала кладет под низ своей колоды карту первого игрока, затем карту второго игрока (то есть карта второго игрока оказывается внизу колоды). Напишите программу, которая моделирует игру в пьяницу и определяет, кто выигрывает. В игре участвует 10 карт, имеющих значения от 0 до 9, большая карта побеждает меньшую, карта со значением 0 побеждает карту 9.

---

**Идея решения:**

1. Используем два массива `[Int]` для очередей карт игроков.
2. На каждом ходу извлекаем по первой карте.
3. Определяем победителя по правилам (`0` побеждает `9`, иначе сравниваем значения).
4. Победитель кладёт карты в порядке: карта первого игрока, карта второго игрока.
5. Считаем количество ходов.
6. Если кто-то остаётся без карт или превышено $10^6$ ходов, завершаем игру и выводим результат.

---

**Оценка сложности:**

* Время: до $10^6$ ходов, каждый ход — $O(1)$
* Память: $O(10)$ для хранения карт двух игроков

---

**Решение задачи (Swift):**

```swift
import Foundation

var first = readLine()!.split(separator: " ").map { Int($0)! }
var second = readLine()!.split(separator: " ").map { Int($0)! }

let maxMoves = 1_000_000
var moves = 0

func firstWins(_ a: Int, _ b: Int) -> Bool {
    return (a == 0 && b == 9) || (a != 0 && !(a < b && !(b == 9 && a == 0)) && !(a == 9 && b == 0) && a > b)
}

while !first.isEmpty && !second.isEmpty && moves < maxMoves {
    let card1 = first.removeFirst()
    let card2 = second.removeFirst()
    
    if (card1 == 0 && card2 == 9) || (card1 != 0 && !(card1 < card2 && !(card2 == 9 && card1 == 0)) && !(card1 == 9 && card2 == 0) && card1 > card2) {
        first.append(contentsOf: [card1, card2])
    } else {
        second.append(contentsOf: [card1, card2])
    }
    moves += 1
}

if moves >= maxMoves {
    print("botva")
} else if first.isEmpty {
    print("second \(moves)")
} else {
    print("first \(moves)")
}
```

### 147. [Дек с защитой от ошибок](https://coderun.yandex.ru/problem/dec-with-error-protection)
**Условие задачи:**
Научитесь пользоваться стандартной структурой данных deque для целых чисел. Реализуйте все команды, выводя результаты после каждой команды.

---

**Идея решения:**

1. Используем массив `[Int]` как внутреннее хранилище дека.
2. Для `push_front` и `push_back` используем `insert` и `append`.
3. Для `pop_front` и `pop_back` проверяем, что дек не пуст, и извлекаем элемент с соответствующего конца.
4. Команды `front` и `back` возвращают элементы без удаления, с проверкой на пустоту.
5. Остальные команды (`size`, `clear`, `exit`) выполняем напрямую.

---

**Оценка сложности:**

* Время: $O(1)$ для `push_back`, `pop_back`, `back`, `size`, `clear`; $O(N)$ для `push_front` и `pop_front` из-за сдвига элементов.
* Память: $O(N)$, где $N \le 100$.

---

**Решение задачи (Swift):**

```swift
import Foundation

var deque: [Int] = []

while let line = readLine() {
    let parts = line.split(separator: " ")
    let command = parts[0]

    switch command {
    case "push_front":
        let n = Int(parts[1])!
        deque.insert(n, at: 0)
        print("ok")
    case "push_back":
        let n = Int(parts[1])!
        deque.append(n)
        print("ok")
    case "pop_front":
        if deque.isEmpty {
            print("error")
        } else {
            print(deque.removeFirst())
        }
    case "pop_back":
        if deque.isEmpty {
            print("error")
        } else {
            print(deque.removeLast())
        }
    case "front":
        if deque.isEmpty {
            print("error")
        } else {
            print(deque.first!)
        }
    case "back":
        if deque.isEmpty {
            print("error")
        } else {
            print(deque.last!)
        }
    case "size":
        print(deque.count)
    case "clear":
        deque.removeAll()
        print("ok")
    case "exit":
        print("bye")
        exit(0)
    default:
        break
    }
}
```

### 148. [Хипуй](https://coderun.yandex.ru/problem/hipuy)
**Условие задачи:**
В этой задаче вам необходимо самостоятельно (не используя соответствующие классы и функции стандартной библиотеки) организовать структуру данных Heap для хранения целых чисел, над которой определены следующие операции:

a) Insert(k) – добавить в Heap число k ;
b) Extract достать из Heap наибольшее число (удалив его при этом).

---

**Идея решения:**

1. Используем массив `[Int]` для хранения кучи (максимальная куча).
2. При вставке (`Insert`) добавляем элемент в конец массива и «всплываем» его, поддерживая свойства кучи.
3. При извлечении максимального элемента (`Extract`) меняем корень с последним элементом, удаляем последний, и «просеиваем» новый корень вниз.
4. Каждая операция выполняется за $O(\log N)$.

---

**Оценка сложности:**

* Время: $O(N \log N)$ для N команд
* Память: $O(N)$

---

**Решение задачи (Swift):**

```swift
import Foundation

class MaxHeap {
    var heap: [Int] = []

    func insert(_ x: Int) {
        heap.append(x)
        var idx = heap.count - 1
        while idx > 0 {
            let parent = (idx - 1) / 2
            if heap[idx] > heap[parent] {
                heap.swapAt(idx, parent)
                idx = parent
            } else {
                break
            }
        }
    }

    func extract() -> Int {
        let maxValue = heap[0]
        heap[0] = heap[heap.count - 1]
        heap.removeLast()
        var idx = 0
        while true {
            let left = 2*idx + 1
            let right = 2*idx + 2
            var largest = idx
            if left < heap.count && heap[left] > heap[largest] { largest = left }
            if right < heap.count && heap[right] > heap[largest] { largest = right }
            if largest == idx { break }
            heap.swapAt(idx, largest)
            idx = largest
        }
        return maxValue
    }
}

let N = Int(readLine()!)!
let heap = MaxHeap()

for _ in 0..<N {
    let line = readLine()!.split(separator: " ")
    if line[0] == "0" {
        heap.insert(Int(line[1])!)
    } else {
        print(heap.extract())
    }
}
```

### 149. [Пирамидальная сортировка](https://coderun.yandex.ru/problem/pyramid-sorting)
**Условие задачи:**
Отсортируйте данный массив. Используйте пирамидальную сортировку.

---

**Идея решения:**

1. Реализуем **heap sort**:

   * Построим **максимальную кучу** из массива.
   * Последовательно извлекаем максимум, уменьшая размер кучи, и восстанавливаем свойства кучи.
2. В результате получаем отсортированный массив по неубыванию.

---

**Оценка сложности:**

* Время: $O(N \log N)$
* Память: $O(1)$ дополнительная (сортировка на месте)

---

**Решение задачи (Swift):**

```swift
import Foundation

let N = Int(readLine()!)!
var arr = readLine()!.split(separator: " ").map { Int($0)! }

func heapify(_ arr: inout [Int], _ n: Int, _ i: Int) {
    var largest = i
    let left = 2*i + 1
    let right = 2*i + 2

    if left < n && arr[left] > arr[largest] {
        largest = left
    }
    if right < n && arr[right] > arr[largest] {
        largest = right
    }
    if largest != i {
        arr.swapAt(i, largest)
        heapify(&arr, n, largest)
    }
}

// Построение кучи
for i in stride(from: N/2 - 1, through: 0, by: -1) {
    heapify(&arr, N, i)
}

// Сортировка
for i in stride(from: N-1, through: 0, by: -1) {
    arr.swapAt(0, i)
    heapify(&arr, i, 0)
}

print(arr.map { String($0) }.joined(separator: " "))
```

### 150. [Три единицы подряд](https://coderun.yandex.ru/problem/three-blocks-row)
**Условие задачи:**
По данному числу N определите количество последовательностей из нулей и единиц длины N, в которых никакие три единицы не стоят рядом.

---

**Идея решения:**
Используем динамическое программирование:

* Пусть `dp[i][c]` — количество последовательностей длины `i`, которые оканчиваются на `c` единиц подряд (`c = 0, 1, 2`).
* Переходы:

  * Добавляем `0` → обнуляем счётчик единиц подряд.
  * Добавляем `1` → увеличиваем счётчик единиц, если `c < 2`.
* Ответ = сумма `dp[N][0] + dp[N][1] + dp[N][2]`.

---

**Оценка сложности:**

* Время: $O(N)$
* Память: $O(N)$

---

**Решение задачи (Swift):**

```swift
import Foundation

let N = Int(readLine()!)!

var dp = Array(repeating: [0, 0, 0], count: N + 1)
dp[0][0] = 1

for i in 1...N {
    // Добавляем 0
    dp[i][0] = dp[i-1][0] + dp[i-1][1] + dp[i-1][2]
    // Добавляем 1
    dp[i][1] = dp[i-1][0]
    dp[i][2] = dp[i-1][1]
}

print(dp[N].reduce(0, +))
```

### 151. [Кузнечик](https://coderun.yandex.ru/problem/grasshopper)
**Условие задачи:**
Кузнечик прыгает по одномерной доске длины N клеток. Он может прыгать на 1, 2, …, k клеток вперёд. Нужно посчитать количество способов, чтобы допрыгать из первой клетки до последней.

---

**Идея решения:**

1. Использовать динамическое программирование.
2. Пусть `dp[i]` — количество способов добраться до клетки `i`.
3. Базовый случай: `dp[1] = 1` (начинаем с первой клетки).
4. Для каждой клетки `i > 1` суммируем `dp[i-j]` для всех `j` от 1 до k, если `i-j >= 1`.

---

**Оценка сложности:**

* Время: $O(N \cdot k)$, где $N \le 30$, $k \le 10$.
* Память: $O(N)$.

---

**Решение задачи (Swift):**

```swift
import Foundation

let line = readLine()!.split(separator: " ").map { Int($0)! }
let N = line[0], k = line[1]

var dp = Array(repeating: 0, count: N + 1)
dp[1] = 1

for i in 2...N {
    for j in 1...k {
        if i - j >= 1 {
            dp[i] += dp[i - j]
        }
    }
}

print(dp[N])
```

### 175. [Уникальные пользователи](https://coderun.yandex.ru/problem/unique-users)
**Условие задачи:**
Пользователи заходят в приложение, вводя свой почтовый адрес. Мы получили логи с нескольких приложений и хотим посчитать количество уникальных пользователей, заходивших в них.

Почтовые адреса состоят из маленьких латинских букв, точек (.), дефисов (-) и одной «собаки» (@). Часть до «собаки» назовем логином, после «собаки» - доменом.

Пользователь может добавлять сколько угодно точек в свой логин, они игнорируются, вход при этом все равно будет успешным. Также пользователь может добавить дефис в свой логин, тогда часть логина после дефиса и сам дефис игнорируются. Например stalker@yandex.ru и s.t.a.l.k.e.r.@yandex.ru считаются одним пользователем, super-user@yandex.ru и sup.er@yandex.ru тоже считаются одним пользователем.

Эти правила не применяются к домену. Два пользователя с одинаковым логином, но разными доменами считаются разными. Назовем окончанием домена подстроку после последней точки. Тогда два домена, отличающиеся только окончаниями, считаются одинаковыми. Например super@mail.yandex.ru и super@mail.yandex.com - один пользователь, super@yandex.com и super@yandex.co.uk - разные пользователи.

При решении на языке Dart используйте ввод и вывод через файлы, стандартный поток ввода работает слишком медленно.

---

**Идея решения:**

1. Разделить email на логин и домен.
2. Преобразовать логин по правилам (убрать точки и усеечь после дефиса).
3. Преобразовать домен, оставив только часть до последней точки и окончание (для сравнения).
4. Собрать уникальные пары `(логин, домен_окончание)` в множество.
5. Размер множества = количество уникальных пользователей.

---

**Оценка сложности:**

* Время: $O(N \cdot L)$, где $N \le 10^5$, $L < 50$ — длина email.
* Память: $O(N)$ для хранения уникальных пользователей.

---

**Решение задачи (Dart, работа с файлами):**

```dart
import 'dart:io';

void main() {
  final input = File('input.txt').readAsLinesSync();
  int n = int.parse(input[0]);
  Set<String> users = {};

  for (int i = 1; i <= n; i++) {
    String email = input[i];
    int atIndex = email.indexOf('@');
    String login = email.substring(0, atIndex);
    String domain = email.substring(atIndex + 1);

    // Обработка логина
    int dashIndex = login.indexOf('-');
    if (dashIndex != -1) {
      login = login.substring(0, dashIndex);
    }
    login = login.replaceAll('.', '');

    // Обработка домена (оставляем до последней точки и конец)
    int lastDot = domain.lastIndexOf('.');
    String domainBase = domain.substring(0, lastDot);
    String domainEnd = domain.substring(lastDot + 1);
    String domainKey = '$domainBase.$domainEnd';

    // Уникальный ключ пользователя
    users.add('$login@$domainEnd');
  }

  File('output.txt').writeAsStringSync('${users.length}\n');
}
```

### 220. [Нормализация показателей](https://coderun.yandex.ru/problem/normalization-of-indicators)
**Условие задачи:**
Разработчики сервиса сбора данных решили уменьшить количество возможных вариантов ответов. Для этого выбрали n различных целых чисел — канонические варианты.

Но в системе уже имеется m старых ответов. Для каждого из этих m чисел необходимо найти ближайший из n канонических вариантов, т.е. с минимальным модулем разности.

**Формат ввода:**
Первая строка содержит целое число n (1≤n≤50 000).
Во второй строке n целых чисел a₁, a₂, …, aₙ — канонические ответы.
В третьей строке одно целое число m (1≤m≤50 000).
В j-й из следующих m строк одно целое число bⱼ.

Гарантируется, что все входные числа не превосходят 10⁶ по абсолютной величине.

**Формат вывода:**
Для каждого значения bⱼ найдите каноническое значение (ближайшее). Если оптимальных значений несколько, выведите любое из них.

**Идея решения:**

* Отсортировать массив канонических вариантов.
* Для каждого старого ответа использовать бинарный поиск по отсортированному массиву, чтобы найти ближайшее число.
* Проверять ближайшее число слева и справа от позиции вставки, чтобы выбрать минимальную разницу.

**Оценка сложности:**

* Сортировка канонических вариантов: O(n log n)
* Для каждого из m чисел бинарный поиск: O(m log n)
* Общая сложность: O(n log n + m log n)

**Решение задачи (Swift):**

```swift
import Foundation

let n = Int(readLine()!)!
var a = readLine()!.split(separator: " ").map { Int($0)! }
a.sort()

let m = Int(readLine()!)!
var b = [Int]()
for _ in 0..<m {
    b.append(Int(readLine()!)!)
}

func closest(_ x: Int) -> Int {
    var l = 0
    var r = a.count - 1
    while l <= r {
        let mid = (l + r) / 2
        if a[mid] == x { return a[mid] }
        else if a[mid] < x { l = mid + 1 }
        else { r = mid - 1 }
    }
    var candidates = [Int]()
    if l < a.count { candidates.append(a[l]) }
    if l - 1 >= 0 { candidates.append(a[l - 1]) }
    return candidates.min(by: { abs($0 - x) < abs($1 - x) })!
}

for x in b {
    print(closest(x))
}
```


### 272. [Простая подсказка](https://coderun.yandex.ru/problem/simple-suggest)
**Условие задачи:**
Вика разрабатывает умную IDE и хочет перед вводом кода видеть первую букву самых часто используемых команд.

Вика уже написала код, который хранит и обновляет список используемых команд. Помогите ей реализовать функцию поиска буквы, с которой чаще всего начинаются команды.

**Формат ввода:**
Первая строка входных данных содержит целое число n (1≤n≤100) — количество команд. Далее следует n строк, каждая из которых содержит строку sᵢ (1≤|sᵢ|≤100), состоящую только из строчных и заглавных латинских букв.

**Формат вывода:**
Выведите единственную букву — букву, с которой чаще всего начинаются команды.
Если вариантов ответа несколько, выведите любой из них.

**Идея решения:**

* Для каждой команды берём первую букву.
* Подсчитываем количество встреч каждой буквы.
* Находим букву с максимальным количеством вхождений.
* Если несколько букв имеют одинаковое максимальное количество, можно вывести любую.

**Оценка сложности:**

* Время: O(n) — проходим по всем командам один раз.
* Память: O(1) — так как всего 52 возможных первых букв (A–Z, a–z).

**Решение задачи (Swift):**

```swift
import Foundation

let n = Int(readLine()!)!
var freq = [Character: Int]()

for _ in 0..<n {
    let s = readLine()!
    let firstChar = s.first!
    freq[firstChar, default: 0] += 1
}

if let maxEntry = freq.max(by: { $0.value < $1.value }) {
    print(maxEntry.key)
}
```



### 290. [Игра](https://coderun.yandex.ru/problem/game)

**Условие задачи:**
В свободное от занятий по программированию время Вася любит играть в самостоятельно придуманную им игру «Жизнь».

Игра происходит на поле, состоящем из n×m одинаковых клеток. Для удобства Вася нумерует все строки поля целыми числами от 1 до n в порядке сверху-вниз, а также нумерует все столбцы поля целыми числами от 1 до m в порядке слева-направо.

Вася считает соседними те клетки поля, которые имеют общее ребро.

Процесс игры состоит из k итераций. На каждой итерации игры каждая клетка поля находится в одном из трех состояний:

* Неактивна. На поле Вася помечает такую клетку цифрой 1.
* Стабильна. На поле Вася помечает такую клетку цифрой 2.
* Нестабильна. На поле Вася помечает такую клетку цифрой 3.

Активными Вася называет те клетки поля, которые находятся в стабильном или нестабильном состояниях.

Вася начинает игру с поля, каждая клетка которого находится в некотором заранее выбранном им состоянии.

При переходе к следующей итерации игры Вася формирует новое поле, состояние каждой клетки в котором назначается по следующим правилам:

1. Если у клетки на предыдущей итерации была более, чем одна соседняя клетка в стабильном состоянии, то на следующей итерации клетка будет находиться в стабильном состоянии.
2. Если не выполняется первое правило и у клетки на предыдущей итерации был хотя бы один сосед в активном состоянии, то на следующей итерации клетка будет находиться в нестабильном состоянии.
3. Если не выполняются предыдущие правила, то на следующей итерации клетка будет находиться в неактивном состоянии.

Вася хочет заранее спланировать для каждой клетки, сколько изменений состояния ему придется сделать за весь ход игры.

**Формат ввода:**
В первой строке входных данных записано три целых числа — n, m, k (1≤n,m,k≤100).
В последующих n строках записано состояние каждой клетки исходно выбранного Васей поля. В i-й (1≤i≤n) из этих строк записано m чисел — aᵢ₁,…,aᵢₘ, где aᵢⱼ∈{1,2,3} — состояние клетки в строке с номером i и столбце с номером j.
Все числа в каждой строке разделены ровно одним пробелом.

**Формат вывода:**
В i-й (1≤i≤n) строке выходных данных Вам необходимо вывести m целых чисел — bᵢ₁,…,bᵢₘ, где bᵢⱼ — количество изменений состояния клетки в строке с номером i и столбце j.

**Идея решения:**

* Для каждого шага создаём копию поля для следующей итерации.
* Для каждой клетки проверяем её 4 соседей и считаем:

  * Сколько соседей стабильно (2).
  * Сколько соседей активно (2 или 3).
* Применяем правила изменения состояния клетки.
* Если новое состояние отличается от предыдущего, увеличиваем счётчик изменений.
* Повторяем процесс k раз.

**Оценка сложности:**

* Время: O(n·m·k) — для каждой клетки на каждой итерации проверяем до 4 соседей.
* Память: O(n·m) — храним текущее состояние и счётчик изменений.

**Решение задачи (Swift):**

```swift
import Foundation

let nk = readLine()!.split(separator: " ").map { Int($0)! }
let n = nk[0], m = nk[1], k = nk[2]

var field = [[Int]]()
for _ in 0..<n {
    let row = readLine()!.split(separator: " ").map { Int($0)! }
    field.append(row)
}

var changes = Array(repeating: Array(repeating: 0, count: m), count: n)

let dx = [-1, 1, 0, 0]
let dy = [0, 0, -1, 1]

for _ in 0..<k {
    var newField = field
    for i in 0..<n {
        for j in 0..<m {
            var stableNeighbors = 0
            var activeNeighbors = 0
            for d in 0..<4 {
                let ni = i + dx[d]
                let nj = j + dy[d]
                if ni >= 0 && ni < n && nj >= 0 && nj < m {
                    if field[ni][nj] == 2 {
                        stableNeighbors += 1
                        activeNeighbors += 1
                    } else if field[ni][nj] == 3 {
                        activeNeighbors += 1
                    }
                }
            }
            var newState = 1
            if stableNeighbors > 1 {
                newState = 2
            } else if activeNeighbors > 0 {
                newState = 3
            }
            if newState != field[i][j] {
                changes[i][j] += 1
            }
            newField[i][j] = newState
        }
    }
    field = newField
}

for row in changes {
    print(row.map { String($0) }.joined(separator: " "))
}
```

### 294. [Сумма различных](https://coderun.yandex.ru/problem/summ-of-the-various)
**Условие задачи:**
Дан массив a из n целых чисел. Напишите программу, которая выведет сумму различных чисел в массиве.

**Формат ввода:**
В первой строке входных данных записано число n (1≤n≤100 000).
Во второй строке записаны n целых чисел aᵢ (0≤aᵢ≤1 000 000 000).

**Формат вывода:**
Выведите единственное число s — сумму различных чисел в массиве a.
Будьте внимательны в выборе используемого целочисленного типа данных.

**Идея решения:**

* Использовать множество для хранения уникальных элементов массива.
* Пройтись по массиву и добавить каждый элемент во множество.
* Суммировать все элементы множества.

**Оценка сложности:**

* Время: O(n)
* Память: O(n)

**Решение задачи (Swift):**

```swift
import Foundation

let n = Int(readLine()!)!
let numbers = readLine()!.split(separator: " ").map { Int($0)! }

var uniqueNumbers = Set<Int>()
for num in numbers {
    uniqueNumbers.insert(num)
}

let sum = uniqueNumbers.reduce(0, +)
print(sum)
```


### 302. [Восстановить матрицу](https://coderun.yandex.ru/problem/restore-the-matrix)
**Условие задачи:**
Для создания сервиса бонусов была предложена следующая схема:

Выбирается целое число n.
В помеченные ячейки матрицы n×n записываются n различных чисел от 1 до n².
Остальные n²−n ячеек остаются пустыми.
Пользователь получает бонус, если угадывает числа, расположенные в помеченных ячейках.
Для получения бонуса нужно заполнить матрицу n×n таким образом, чтобы все числа от 1 до n² встречались ровно один раз, а во всех помеченных ячейках числа совпадали с выигрышным шаблоном.

Найдите любую выигрышную матрицу.

**Формат ввода:**
В первой строке входных данных записано целое число n (2≤n≤100).
Далее в n строках записаны числа в матрице-шаблоне aᵢⱼ (0≤aᵢⱼ≤n²).
Если aᵢⱼ=0, то соответствующая ячейка матрицы не является помеченной и должна быть заполнена.
Если aᵢⱼ≠0, то в соответствующую ячейку матрицы нужно вписать aᵢⱼ.

**Формат вывода:**
Выведите n строк по n целых чисел — любую из выигрышных матриц.
Гарантируется, что существует как минимум одна выигрышная матрица.

**Идея решения:**

* Создать множество всех чисел от 1 до n².
* Убрать из него все числа, уже указанные в шаблоне.
* Пройти по матрице и заменить все нули оставшимися числами из множества в любом порядке.
* Это гарантирует корректную матрицу, удовлетворяющую условиям.

**Оценка сложности:**

* Время: O(n²)
* Память: O(n²)

**Решение задачи (Swift):**

```swift
import Foundation

let n = Int(readLine()!)!
var matrix = [[Int]]()
var used = Set<Int>()

for _ in 0..<n {
    let row = readLine()!.split(separator: " ").map { Int($0)! }
    matrix.append(row)
    for num in row where num != 0 {
        used.insert(num)
    }
}

var remaining = Array(Set(1...n*n).subtracting(used)).sorted()
var idx = 0

for i in 0..<n {
    for j in 0..<n {
        if matrix[i][j] == 0 {
            matrix[i][j] = remaining[idx]
            idx += 1
        }
    }
}

for row in matrix {
    print(row.map { String($0) }.joined(separator: " "))
}
```


### 304. [Проверка палиндрома](https://coderun.yandex.ru/problem/palindroming-check)

**Условие задачи:**
Палиндром, перевертень — число, буквосочетание, слово или текст, одинаково читающееся в обоих направлениях. Например, число 404; слова «топот» в русском языке и фин. «saippuakivikauppias» (продавец мыла; торговец щёлоком) — самое длинное слово-палиндром в мире; текст «а роза упала на лапу Азора» и пр. (Wikipedia)

Вам дана строка s, состоящая только из букв английского алфавита и пробелов. Напишите программу, которая определит, является ли строка s палиндромом.

Обратите внимание, что в использованном определении палиндрома пробелы игнорируются, а строчные и заглавные буквы не различаются.

**Формат ввода:**
В единственной строке записана одна строка s (1≤|s|≤500000). Строка не начинается и не заканчивается пробельными символами.

**Формат вывода:**
В единственной строке выведите It is a palindrome, если s является палиндромом, иначе выведите It is not a palindrome. Программа проверки учитывает регистр.

**Идея решения:**

* Игнорируем пробелы и приводим все буквы к одному регистру (например, к нижнему).
* Используем два указателя: один с начала строки, другой с конца.
* Сравниваем символы попарно, двигаясь к центру строки.
* Если все пары совпадают, строка — палиндром; иначе — нет.

**Оценка сложности:**

* Время: O(n), где n — длина строки
* Память: O(n) (для хранения строки без пробелов и в нижнем регистре)

**Решение задачи (Swift):**

```swift
import Foundation

let s = readLine()!
let cleaned = s.lowercased().filter { $0 != " " }
var left = cleaned.startIndex
var right = cleaned.index(before: cleaned.endIndex)
var isPalindrome = true

while left < right {
    if cleaned[left] != cleaned[right] {
        isPalindrome = false
        break
    }
    left = cleaned.index(after: left)
    right = cleaned.index(before: right)
}

print(isPalindrome ? "It is a palindrome" : "It is not a palindrome")
```


### 310. [Кодирование длин серий](https://coderun.yandex.ru/problem/rle-test)
**Условие задачи:**
Кодирование длин серий (RLE) — алгоритм сжатия данных, заменяющий повторяющиеся символы на один символ и число его повторов. Серией называется последовательность, состоящая из нескольких одинаковых символов (более одного). При кодировании строка одинаковых символов, составляющих серию, заменяется строкой, содержащей сам повторяющийся символ и количество его повторов.

Например, строка AAAABBB будет сжата в строку A4B3, а строка AAAAAAAAAAAAAAABAAAAA — в строку A15BA5.

Вам дана сжатая строка, найдите длину исходной строки. Длина исходной строки не превосходит 1000 символов, все символы исходной строки — заглавные большие буквы латинского алфавита.

**Формат ввода:**
В единственной строке входных данных содержится непустая строка s. Гарантируется, что s результат корректного сжатия некоторой строки.

**Формат вывода:**
Выведите длину исходной строки.

**Идея решения:**

* Проходим по сжатой строке символ за символом.
* Если встречаем букву, проверяем, идут ли за ней цифры.
* Если цифры есть, они обозначают количество повторений буквы; если цифр нет — это одиночная буква (длина 1).
* Суммируем все повторения для получения длины исходной строки.

**Оценка сложности:**

* Время: O(n), где n — длина сжатой строки
* Память: O(1)

**Решение задачи (Swift):**

```swift
import Foundation

let s = readLine()!
var length = 0
var i = s.startIndex

while i < s.endIndex {
    let char = s[i]
    i = s.index(after: i)
    
    var countStr = ""
    while i < s.endIndex, s[i].isNumber {
        countStr.append(s[i])
        i = s.index(after: i)
    }
    
    if let count = Int(countStr) {
        length += count
    } else {
        length += 1
    }
}

print(length)
```

### 374. [Оценка](https://coderun.yandex.ru/problem/mark)
**Условие задачи:**
В Школе Мобильной Разработки оценивание студента происходит следующим образом. Три эксперта выставляют предварительные оценки, представленные целыми положительными числами. Итоговая оценка равняется целому числу x, если есть хотя бы два эксперта, которые поставили оценку больше, либо равную x и есть хотя бы два эксперта, которые поставили оценку меньше, либо равную x.

Вам даны предварительные оценки трех экспертов. Определите итоговую оценку.

**Формат ввода:**
На первой строке входных данных находятся три целых положительных числа a, b, c.

**Ограничения:**
1 ≤ a, b, c ≤ 2⁶³ − 1

**Формат вывода:**
Выведите одно целое число — итоговую оценку.

Примечание:
В первом примере итоговая оценка равняется 3, ибо первый и третий эксперт поставили оценки ≤3, а второй и третий эксперт поставили оценки ≥3. Во втором примере ответ 3, ибо первый и второй эксперт поставили оценки ≤3, а первый, второй и третий эксперт поставили оценки ≥3.

**Идея решения:**

* Для трёх чисел a, b, c итоговая оценка x — это число, которое находится между минимальной и максимальной оценками, так как оно удовлетворяет условию "хотя бы два ≥ x и хотя бы два ≤ x".
* Для трёх чисел это просто **медиана** этих чисел.

**Оценка сложности:**

* Время: O(1)
* Память: O(1)

**Решение задачи (Swift):**

```swift
import Foundation

let numbers = readLine()!.split(separator: " ").map { Int($0)! }
let a = numbers[0], b = numbers[1], c = numbers[2]

let result = max(min(a, b), min(max(a, b), c))
print(result)
```

### 405. [Тетрамино](https://coderun.yandex.ru/problem/tetramino)
**Условие задачи:**
На шахматном поле 8×8 некоторые клетки пустые, а некоторые заняты фигурами.

Определите количество способов разместить тетрамино на этом поле, чтобы фигура занимала целиком четыре свободные клетки.

В задаче мы рассматриваем тетрамино только одного типа.

**Формат ввода:**
Входные данные состоят из 8 строк по 8 символов. Пустая клетка задается точкой `.` , а занятая — звездочкой `*`.

**Формат вывода:**
Выведите количество способов разместить тетрамино на поле.

**Идея решения:**

* Тетрамино одного типа можно разместить как горизонтально 4×1 или вертикально 1×4.
* Проходим по каждой возможной позиции для горизонтального и вертикального расположения и проверяем, что все клетки свободны (`.`).
* Считаем все допустимые варианты.

**Оценка сложности:**

* Время: O(8×8) = O(64), так как поле фиксированного размера.
* Память: O(8×8) для хранения поля.

**Решение задачи (Swift):**

```swift
import Foundation

var board: [[Character]] = []
for _ in 0..<8 {
    let line = Array(readLine()!)
    board.append(line)
}

var count = 0

// Горизонтальные 1x4
for i in 0..<8 {
    for j in 0..<(8-3) {
        if board[i][j] == "." && board[i][j+1] == "." && board[i][j+2] == "." && board[i][j+3] == "." {
            count += 1
        }
    }
}

// Вертикальные 4x1
for i in 0..<(8-3) {
    for j in 0..<8 {
        if board[i][j] == "." && board[i+1][j] == "." && board[i+2][j] == "." && board[i+3][j] == "." {
            count += 1
        }
    }
}

print(count)
```

### 410. [Сложить и вычесть](https://coderun.yandex.ru/problem/calc-expression)
**Условие задачи:**
Вычислите значение выражения, состоящего только из целых чисел и операций сложения и вычитания.

**Формат ввода:**
Ввод содержит выражение s — непустую строку, содержащую только цифры и символы арифметических операций + (сложение) и - (вычитание). Длина s не превышает 50 000.
Строка s начинается и заканчивается цифрой. Каждое число в выражении является неотрицательным целым числом, содержащим не более шести десятичных разрядов.

**Формат вывода:**
Результат вычисления выражения.

**Идея решения:**

* Пройти по строке, собирая числа и запоминая текущую операцию (+ или -).
* При встрече знака выполнить накопленную операцию с текущим числом.
* Начальное число прибавляется к результату, последующие учитываются в зависимости от знака.

**Оценка сложности:**

* Время: O(n), один проход по строке длины n.
* Память: O(1) для суммы и текущего числа, плюс O(n) на чтение входной строки.

**Решение задачи (Swift):**

```swift
import Foundation

let s = readLine()!

var result = 0
var currentNumber = 0
var sign: Int = 1

for char in s {
    if char.isNumber {
        currentNumber = currentNumber * 10 + Int(String(char))!
    } else {
        result += sign * currentNumber
        currentNumber = 0
        sign = char == "+" ? 1 : -1
    }
}

result += sign * currentNumber
print(result)
```

### 455. [Села батарейка](https://coderun.yandex.ru/problem/dead-battery)
**Условие задачи:**
Производители умных часов стараются заботиться о наилучшем пользовательском опыте. Чтобы часы выполняли свои функции, в них постоянно должны быть активны n приложений. Один из важных показателей работы устройства — то, сколько часов оно сможет работать без подзарядки. Экспериментальным путём для каждого приложения было выяснено, сколько процентов батареи оно тратит в час. Помогите рассчитать, сколько полных часов будут функционировать умные часы, если постоянно будут запущены все приложения.

**Формат ввода:**
В первой строке содержится целое число n — количество стандартных приложений (1 ≤ n ≤ 10⁵).
Во второй строке — n целых чисел a\_i, каждое (1 ≤ a\_i ≤ 100), обозначающих, сколько процентов батареи приложение съедает в час.

**Формат вывода:**
В единственной строке выведите одно целое число — количество полных часов, которые выдержит батарея. Изначально батарея заряжена на все 100%.

**Идея решения:**

* Суммировать процентное потребление всех приложений за один час.
* Разделить 100% батареи на суммарное потребление, чтобы получить количество часов работы.
* Округлить вниз до целого числа (полные часы).

**Оценка сложности:**

* Время: O(n), один проход по списку приложений.
* Память: O(1) для суммарного счетчика, плюс O(n) на хранение входных данных.

**Решение задачи (Swift):**

```swift
import Foundation

let n = Int(readLine()!)!
let consumptions = readLine()!.split(separator: " ").map { Int($0)! }

let totalConsumption = consumptions.reduce(0, +)
let fullHours = 100 / totalConsumption

print(fullHours)
```

### 456. [Запускайте гуся](https://coderun.yandex.ru/problem/release-the-goose)
**Условие задачи:**
Студенты школы мобильных разработчиков создали поисковый движок, который ориентируется на ключевые слова. Например, пользователь ищет информацию о гусях, и поисковому движку выдаётся перечень из n статей с названием сайта и кратким описанием статьи. Если на сайте в кратком описании статей суммарно не менее k раз упомянуто ключевое слово, то, скорее всего, сайт создан для обхода поискового робота и может содержать некачественный контент. Учтите, что если ключевое слово является частью другого слова, это не учитывается как отдельное упоминание. Робот скрывает такие сайты из поисковой выдачи. Определите количество отфильтрованных сайтов и выведите их названия.

**Формат ввода:**
Первая строка содержит два целых числа: n — количество статей, k — количество упоминаний слова goose для применения фильтра (1 ≤ n ≤ 10⁵, 0 ≤ k ≤ 10⁶).
В следующих n парах строк содержатся:

* site\_i — название сайта: строка, не более 20 строчных английских букв;
* message\_i — краткое описание статьи: строка, не более 100 строчных английских букв и пробелов.

Все названия сайтов различны. На одном сайте может быть несколько статей.
Гарантируется, что суммарная длина всех сообщений не превышает 2×10⁶.

**Формат вывода:**
В первой строке выведите количество отфильтрованных сайтов.
В следующих строках выведите в алфавитном порядке названия сайтов, скрытых из поиска.

**Идея решения:**

* Создать словарь, который хранит суммарное количество упоминаний слова `"goose"` для каждого сайта.
* Для каждого сообщения разбить текст на слова и подсчитать количество точных совпадений `"goose"`.
* Обновлять словарь по сайту.
* В конце выбрать сайты, где суммарное количество упоминаний ≥ k, и вывести их в алфавитном порядке.

**Оценка сложности:**

* Время: O(total\_length), где total\_length — суммарная длина всех сообщений (до 2×10⁶).
* Память: O(n), для хранения счетчиков сайтов и названий.

**Решение задачи (Swift):**

```swift
import Foundation

let firstLine = readLine()!.split(separator: " ").map { Int($0)! }
let n = firstLine[0]
let k = firstLine[1]

var siteCounts = [String: Int]()

for _ in 0..<n {
    let site = readLine()!
    let message = readLine()!
    let words = message.split(separator: " ")
    let count = words.filter { $0 == "goose" }.count
    siteCounts[site, default: 0] += count
}

let filteredSites = siteCounts.filter { $0.value >= k }.map { $0.key }.sorted()

print(filteredSites.count)
for site in filteredSites {
    print(site)
}
```

### 458. [Восстановление отчётов](https://coderun.yandex.ru/problem/report-restoration)
**Условие задачи:**
Программист Филипп увидел резкое увеличение ошибок в своей программе. Чтобы понять причины, он принялся изучать отчёты пользователей. Однако вскоре Филипп заметил, что отчёты фиксируют не все переходы между страницами программы. Это вызвело у него вопрос: сколько ещё страниц программы недоступны для анализа по имеющимся отчётам?

**Формат ввода:**
Первая строка содержит два целых числа: n (1 ≤ n ≤ 10³) — количество страниц в программе, m (0 ≤ m ≤ 10⁶) — количество записей в отчётах.
Вторая строка содержит n строк, описывающих названия страниц.
Третья строка содержит одну строку — название главной страницы.
Следующие m строк содержат записи в отчётах. Каждая запись состоит из двух строк: первая — страница, с которой ушёл пользователь, вторая — страница, на которую пользователь перешёл.

Гарантируется, что суммарная длина строк во входных данных не превосходит 10⁶.

**Формат вывода:**
Необходимо вывести количество страниц приложения, до которых невозможно восстановить путь по отчётам.

**Идея решения:**

* Построить граф, где страницы — это вершины, а переходы из отчётов — направленные рёбра.
* Провести обход (DFS или BFS) из главной страницы.
* Посчитать страницы, которые не достижимы из главной.

**Оценка сложности:**

* Время: O(n + m), так как строится граф и делается обход.
* Память: O(n + m), для хранения графа и посещённых страниц.

**Решение задачи (Swift):**

```swift
import Foundation

let firstLine = readLine()!.split(separator: " ").map { Int($0)! }
let n = firstLine[0]
let m = firstLine[1]

var pages = [String]()
var pageIndex = [String: Int]()

for i in 0..<n {
    let name = readLine()!
    pages.append(name)
    pageIndex[name] = i
}

let mainPage = readLine()!
var graph = Array(repeating: [Int](), count: n)

for _ in 0..<m {
    let from = readLine()!
    let to = readLine()!
    if let fromIdx = pageIndex[from], let toIdx = pageIndex[to] {
        graph[fromIdx].append(toIdx)
    }
}

var visited = Array(repeating: false, count: n)
func dfs(_ u: Int) {
    visited[u] = true
    for v in graph[u] {
        if !visited[v] {
            dfs(v)
        }
    }
}

if let start = pageIndex[mainPage] {
    dfs(start)
}

let unreachable = visited.filter { !$0 }.count
print(unreachable)
```

### 467. [Суеверный коллекционер](https://coderun.yandex.ru/problem/next-lucky-ticket)
**Условие задачи:**
Коллекционер древностей Леонард раздобыл редкую античную статуэтку и решил для сохранности спрятать её в сейф в банке. Леонард очень суеверен, поэтому следит, чтобы у банковской ячейки был счастливый номер. Номер каждой ячейки — это шестизначное число. Счастливый номер — тот, в котором сумма первых трёх цифр равна сумме трёх последних.

Например, число 201111 — счастливое, так как суммы первых (2+0+1=3) и последних (1+1+1=3) трёх цифр одинаковы.

Номер ячейки, которую сначала предложили Леонарду, не был счастливым, поэтому коллекционер отправился искать ячейку с ближайшим счастливым номером.

Например, если номер ячейки — 165901, то ближайшей счастливой (в последовательности возрастания) будет ячейка 165903.

**Формат ввода:**
Первая строка содержит целое число number (100000 ≤ number ≤ 999999) — шестизначный номер ячейки.

**Формат вывода:**
Для числа во входных данных найдите и выведите следующее счастливое число. Гарантируется, что такое число существует.

**Идея решения:**

* Преобразуем число в массив цифр.
* Определяем сумму первых трёх цифр.
* Для последних трёх цифр ищем минимальное число, которое даст ту же сумму.
* Если минимальное число для последних трёх цифр меньше текущего, увеличиваем число на 1 в старших цифрах и повторяем процесс.
* Это позволит найти ближайший следующий счастливый номер без полного перебора.

**Оценка сложности:**

* Время: O(1), так как работа ведётся с фиксированным числом из 6 цифр.
* Память: O(1).

**Решение задачи (Swift):**

```swift
import Foundation

func digits(of number: Int) -> [Int] {
    return String(number).compactMap { $0.wholeNumberValue }
}

func number(from digits: [Int]) -> Int {
    return digits.reduce(0) { $0 * 10 + $1 }
}

func nextLuckyNumber(_ number: Int) -> Int {
    var num = number + 1
    while num <= 999999 {
        let d = digits(of: num)
        let sum1 = d[0] + d[1] + d[2]
        let sum2 = d[3] + d[4] + d[5]
        if sum1 == sum2 {
            return num
        }
        num += 1
    }
    return -1 // На случай невозможного, но по условию гарантировано существует
}

let number = Int(readLine()!)!
print(nextLuckyNumber(number))
```

### 469. [Игра в города](https://coderun.yandex.ru/problem/city-games)
**Условие задачи:**
На вход подаются две строки, в каждой из них перечислены страны и их столицы. Однако не гарантируется, что первым всегда написано название страны, а затем — название столицы. Нужно определить, являются ли два набора названий одинаковыми или нет.

**Формат ввода:**
На вход подаются две строки. Все пары «страна + город» перечислены строго через запятую. Названием страны или города является строка, состоящая только из букв или цифр. В конце каждой строки стоит точка.

**Формат вывода:**
Нужно вывести YES, если наборы названий являются одинаковыми, иначе — NO.

**Идея решения:**

* Разбиваем каждую строку по запятым, удаляем точку в конце.
* Для каждой пары слов сортируем их внутри пары, так как порядок «страна-столица» не гарантирован.
* Формируем множество таких отсортированных пар для каждой строки.
* Сравниваем множества — если они равны, выводим YES, иначе NO.

**Оценка сложности:**

* Время: O(n), где n — количество пар.
* Память: O(n).

**Решение задачи (Swift):**

```swift
import Foundation

func parseLine(_ line: String) -> Set<Set<String>> {
    let trimmed = line.trimmingCharacters(in: CharacterSet(charactersIn: "."))
    let pairs = trimmed.split(separator: ",")
    var result = Set<Set<String>>()
    for pair in pairs {
        let items = pair.split(separator: " ").map { String($0) }
        result.insert(Set(items))
    }
    return result
}

let firstLine = readLine()!
let secondLine = readLine()!

let set1 = parseLine(firstLine)
let set2 = parseLine(secondLine)

print(set1 == set2 ? "YES" : "NO")
```

### 470. [Чёрное и белое](https://coderun.yandex.ru/problem/black-and-white)
**Условие задачи:**
Художник-керамист хочет оформить стену нового общественного пространства чёрно-белой мозаикой, взяв за основу новый тренд — диагональный дизайн. Все мотивы мозаики должны выглядеть как фигуры, изображённые с помощью диагоналей в клеточках. Перед созданием самой мозаики художник собирается отрисовать дизайн в графическом редакторе: он наносит на клетчатую подложку контуры фигур, которые на экране редактора будут залиты белым на чёрном фоне.

Никакая фигура не может касаться другой фигуры или пересекаться с ней, а также ни одна фигура не может содержать в себе никаких диагоналей (ими рисуется только контур фигур).

Чтобы рассчитать количество материалов для создания мозаики, нужно вычислить суммарную площадь фигур (в клеточках) по известным контурам. Гарантируется, что площадь будет целым числом.

**Формат ввода:**
В первой строке записаны два числа n и m (1≤n,m≤100) — размеры изображения в клеточках.
В следующих n строках записано по m символов. Каждый символ может быть `.` — это пустая клетка (полностью чёрная или белая, не содержащая контура), `/` или `\` — это изображение контура фигуры. Гарантируется, что все контуры замкнуты.

**Формат вывода:**
Выведите одно целое число — суммарную площадь фигур.

**Примечание:**
Обе фигуры в примере имеют площадь 6.

**Идея решения:**

* Каждую клетку с диагональю можно рассматривать как половину клетки, так как диагонали делят клетку на два треугольника.
* Для подсчёта площади можно применить алгоритм заливки (Flood Fill) на «половинчатой» сетке, где каждая клетка разделена на две половины по диагонали.
* Считаем количество половин внутри каждой фигуры и делим на 2, чтобы получить целую площадь в клетках.
* Так как все фигуры замкнуты и не пересекаются, можно последовательно заливать каждую область.

**Оценка сложности:**

* Время: O(n\*m), так как проходим по каждой половине каждой клетки один раз.
* Память: O(n\*m) для сетки.

**Решение задачи (Swift):**

```swift
import Foundation

let nm = readLine()!.split(separator: " ").map { Int($0)! }
let n = nm[0], m = nm[1]

var grid = [[Character]]()
for _ in 0..<n {
    grid.append(Array(readLine()!))
}

// Разделяем каждую клетку на две половины: верхнюю и нижнюю
// Используем сетку размером 2n x 2m для упрощения Flood Fill
var fillGrid = Array(repeating: Array(repeating: 0, count: 2*m), count: 2*n)

for i in 0..<n {
    for j in 0..<m {
        switch grid[i][j] {
        case "/":
            fillGrid[2*i][2*j+1] = -1
            fillGrid[2*i+1][2*j] = -1
        case "\\":
            fillGrid[2*i][2*j] = -1
            fillGrid[2*i+1][2*j+1] = -1
        default:
            break
        }
    }
}

let dirs = [(0,1),(1,0),(0,-1),(-1,0)]
var totalArea = 0

for i in 0..<(2*n) {
    for j in 0..<(2*m) {
        if fillGrid[i][j] == 0 {
            // Flood Fill
            var stack = [(i,j)]
            fillGrid[i][j] = 1
            var count = 0
            while !stack.isEmpty {
                let (x,y) = stack.removeLast()
                count += 1
                for (dx,dy) in dirs {
                    let nx = x + dx, ny = y + dy
                    if nx >= 0 && nx < 2*n && ny >= 0 && ny < 2*m && fillGrid[nx][ny] == 0 {
                        fillGrid[nx][ny] = 1
                        stack.append((nx,ny))
                    }
                }
            }
            totalArea += count
        }
    }
}

// Каждая клетка состоит из 4 половинок в fillGrid
print(totalArea / 4)
```

### 471. [Журнал без дат](https://coderun.yandex.ru/problem/log-without-dates)
**Условие задачи:**
Менеджер колл-центра решил изучить журнал входящих звонков от клиентов, но обнаружил, что из-за ошибки разработчиков для каждого звонка в CRM-системе записывается только время этого звонка в формате HH\:MM\:SS, а дата не записывается.

Известно, что все звонки записаны в хронологическом порядке и два звонка не могли произойти в одну и ту же секунду. Определите минимальное количество дней, в течение которых вёлся журнал звонков.

**Формат ввода:**
Первая строка входных данных содержит единственное число n (1≤n≤100000) — количество звонков в журнале.
Следующие n строк описывают время совершения звонков. Каждая строка имеет формат HH\:MM\:SS, где HH — число от 0 до 23, MM и SS — числа от 0 до 59. Все записи чисел состоят ровно из двух цифр.

**Формат вывода:**
Выведите одно целое число — минимальное количество дней, в течение которых вёлся журнал звонков.

**Идея решения:**

* Преобразовать каждое время в количество секунд с начала дня: `totalSeconds = HH*3600 + MM*60 + SS`.
* Так как звонки идут в хронологическом порядке, если текущее время в секундах меньше предыдущего, значит день сменился, увеличиваем счётчик дней.
* Начальный день считается первым.

**Оценка сложности:**

* Время: O(n), так как проходим один раз по списку звонков.
* Память: O(1) дополнительной памяти, кроме хранения текущего времени.

**Решение задачи (Swift):**

```swift
import Foundation

let n = Int(readLine()!)!
var prevSeconds = -1
var days = 1

for _ in 0..<n {
    let timeStr = readLine()!
    let parts = timeStr.split(separator: ":").map { Int($0)! }
    let seconds = parts[0]*3600 + parts[1]*60 + parts[2]
    
    if prevSeconds != -1 && seconds < prevSeconds {
        days += 1
    }
    
    prevSeconds = seconds
}

print(days)
```

### 475. [Баг в БД](https://coderun.yandex.ru/problem/bug-in-library)
**Условие задачи:**
Вы отправляете запрос к базе данных, однако вместо отсортированного массива строк в ответе формируется массив строк в случайном порядке. К счастью, в каждую строку в случайной позиции записан порядковый индекс — позиция, где строка должна быть в выходном массиве, например str**2**ing.

Ваша задача — обработать баг БД и написать функцию, которая:

* извлечёт индекс из строки;
* с помощью индекса расположит строку в нужной позиции.

**Формат ввода:**
Список строк, разделённых символом переноса строки.

**Формат вывода:**
Список строк, разделённых символом переноса строки.

**Примечание:**

* Индексы всегда начинаются с 1.
* Последовательность индексов неразрывна, то есть не может быть последовательности \[1,2,5].
* В каждой строке существует лишь одна последовательность чисел, то есть не может быть st**2**ri**3**ng.
* На вход подаётся не более 5000 строк длиной не более 10000 символов.
* Суммарная длина строк во вводе не превосходит 15⋅10^6.

**Идея решения:**

* Для каждой строки извлечь число, представляющее индекс, с помощью регулярного выражения или перебора символов.
* Создать массив нужного размера и поместить каждую строку на позицию `index-1`.
* Вывести строки в порядке индексов.

**Оценка сложности:**

* O(n \* L), где n — количество строк, L — средняя длина строки (для поиска числа).
* Память O(n \* L) для хранения массива строк.

**Решение задачи (Swift):**

```swift
import Foundation

var lines: [String] = []
while let line = readLine() {
    lines.append(line)
}

let n = lines.count
var result = Array(repeating: "", count: n)

for line in lines {
    // Найти число в строке
    var numberStr = ""
    for ch in line {
        if ch.isNumber {
            numberStr.append(ch)
        }
    }
    if let index = Int(numberStr) {
        result[index - 1] = line
    }
}

for line in result {
    print(line)
}
```

### 476. [Градиент](https://coderun.yandex.ru/problem/gradient)
**Условие задачи:**
Программист Иван пишет приложение и хочет сделать фон интерфейса программным. Фон должен динамично адаптироваться под разрешение экрана. Иван написал алгоритм, который определяет интенсивность пикселей, выраженную некоторым целым числом. При этом он исходил из того, что экран имеет разрешение W×H, то есть в нём H строк пикселей по W пикселей в каждой строке. Алгоритм выглядит так:

```
for row_min from 0 to H - 1
  for row_max from row_min to H - 1
    for col_min from 0 to W - 1
      for col_max from col_min to W - 1
        * for each pixel in this rectangle increase value by one
```

Например, если W=4 и H=3, то матрица интенсивности пикселей будет такая:

```
12 18 18 12
16 24 24 16
12 18 18 12
```

Если W=10 и H=10, то матрица интенсивности будет такая:

```
100 180 240 280 300 300 280 240 180 100
180 324 432 504 540 540 504 432 324 180
240 432 576 672 720 720 672 576 432 240
280 504 672 784 840 840 784 672 504 280
300 540 720 840 900 900 840 720 540 300
300 540 720 840 900 900 840 720 540 300
280 504 672 784 840 840 784 672 504 280
240 432 576 672 720 720 672 576 432 240
180 324 432 504 540 540 504 432 324 180
100 180 240 280 300 300 280 240 180 100
```

Так как у современных устройств могут быть миллионы пикселей, для проверки программы нужно вывести не всю матрицу интенсивности, а два массива чисел:

* сумму интенсивностей для каждой строки матрицы;
* сумму интенсивностей для каждого столбца матрицы.

**Формат ввода:**
В первой строке входных данных находятся два числа W и H (3 ≤ W ≤ 2532, 3 ≤ H ≤ 1170).

**Формат вывода:**
В первой строке выведите H чисел, i-е число должно равняться сумме интенсивностей в i-й строке матрицы интенсивности пикселей.
Во второй строке выведите W чисел, i-е число должно равняться сумме в соответствующем столбце.
Числа в строках разделяйте пробелами.

**Идея решения:**
Интенсивность пикселя в позиции (i,j) равна числу прямоугольников, в которые он входит: `(i+1)*(H-i)*(j+1)*(W-j)`.
Сумма по строкам: для строки i суммируем по всем столбцам `(i+1)*(H-i)*(j+1)*(W-j)` = `(i+1)*(H-i) * sum_{j=0}^{W-1} (j+1)*(W-j)`.
Аналогично для столбцов: сумма для столбца j = `(j+1)*(W-j) * sum_{i=0}^{H-1} (i+1)*(H-i)`.
Используем формулы суммы последовательностей: sum\_{x=1}^{n} x\*(n+1-x) = n\*(n+1)\*(n+2)/6.

**Оценка сложности:**

* O(H + W), так как требуется вычислить H строк и W столбцов.
* Память O(H + W) для хранения сумм.

**Решение задачи (Swift):**

```swift
import Foundation

let line = readLine()!.split(separator: " ").map { Int($0)! }
let W = line[0], H = line[1]

func sumLineOrCol(_ n: Int) -> Int {
    return n * (n + 1) * (n + 2) / 6
}

let sumColsPart = sumLineOrCol(W)
let sumRowsPart = sumLineOrCol(H)

var rowSums: [Int] = []
for i in 0..<H {
    rowSums.append((i+1)*(H-i)*sumColsPart)
}
print(rowSums.map { String($0) }.joined(separator: " "))

var colSums: [Int] = []
for j in 0..<W {
    colSums.append((j+1)*(W-j)*sumRowsPart)
}
print(colSums.map { String($0) }.joined(separator: " "))
```

### 478. [Сокращение маршрута](https://coderun.yandex.ru/problem/route-reduction)
**Условие задачи:**
Дмитрий участвует в пешеходном квесте, цель которого — дойти из точки А в точку Б. Его друг Георгий уже проходил этот квест и составил краткое описание маршрута с направлениями движения и дистанциями. Однако он неправильно решал некоторые задания и шёл по неверному пути, из-за чего в описании встречаются тупики. Дмитрий очень хочет поскорее пройти маршрут и не тратить на тупики драгоценное время. Он обратился к вам с просьбой, чтобы вы могли убрать из маршрута тупики и сократить одинаковые направления, если они идут друг за другом.

Маршрутом считается набор действий. Каждое действие задаётся двумя параметрами — направлением и дистанцией. Дистанции бывают только целочисленными.

Тупиком считаются последовательные действия в строго противоположных направлениях движения. Например, если требуется пойти TOP 50 и следующим шагом BOTTOM 50, то это считается тупиком и такие действия можно полностью сократить (тогда в выводе не должно быть этих строчек). Однако если дистанции не сокращаются полностью, то полностью сократить действия нельзя. Например, если требуется пойти TOP 50 и следующим шагом BOTTOM 40, то можно сократить в TOP 10.

Тупиком не считается возвращение в точку маршрута по другой дороге. Например, если требуется пойти TOP 50, RIGHT 50, BOTTOM 50, LEFT 50, BOTTOM 10, то эти действия сократить до BOTTOM 10 нельзя.

Пример одинаковых направлений, идущих друг за другом, — BOTTOM 50, BOTTOM 50. Такой набор действий необходимо сократить в BOTTOM 100.

**Формат ввода:**
На вход подаётся список действий изначального маршрута. Каждое действие задаётся двумя параметрами — направлением Ri (LEFT, RIGHT, TOP или BOTTOM) и дистанцией Di (0 < Di < 10^4), разделёнными пробелом. Количество строк во входных данных не превышает 1000.

**Формат вывода:**
В качестве ответа необходимо вывести сокращённый маршрут. Каждая строка — действие, в том же формате, что и во входных данных.

**Идея решения:**
Используем стек для хранения текущих действий маршрута. Проходим по списку действий:

* Если текущее направление совпадает с верхом стека, суммируем расстояния.
* Если направление противоположное верхнему элементу стека, вычисляем разницу расстояний: полностью или частично сокращаем действия.
* Иначе просто добавляем действие в стек.
  После обработки всех действий стек содержит сокращённый маршрут в порядке прохождения.

**Оценка сложности:**

* O(n), где n — количество действий (до 1000).
* Память O(n) для хранения стека.

**Решение задачи (Swift):**

```swift
import Foundation

let opposites: [String: String] = [
    "TOP": "BOTTOM",
    "BOTTOM": "TOP",
    "LEFT": "RIGHT",
    "RIGHT": "LEFT"
]

var actions: [(String, Int)] = []

while let line = readLine(), !line.isEmpty {
    let parts = line.split(separator: " ")
    let dir = String(parts[0])
    let dist = Int(parts[1])!
    actions.append((dir, dist))
}

var stack: [(String, Int)] = []

for (dir, dist) in actions {
    if let last = stack.last {
        if last.0 == dir {
            stack[stack.count - 1].1 += dist
        } else if opposites[last.0] == dir {
            if last.1 > dist {
                stack[stack.count - 1].1 -= dist
            } else if last.1 < dist {
                stack.removeLast()
                stack.append((dir, dist - last.1))
            } else {
                stack.removeLast()
            }
        } else {
            stack.append((dir, dist))
        }
    } else {
        stack.append((dir, dist))
    }
}

for (dir, dist) in stack {
    print("\(dir) \(dist)")
}
```


### 543. [Классы подобия треугольников](https://coderun.yandex.ru/problem/triangle-similarity)
**Условие задачи:**
Вам дан набор из n треугольников (1 ≤ n ≤ 1 000 000). Каждый треугольник задается тремя целыми числами — длинами его сторон. Длины сторон — положительные целые числа, не превышающие 10^9. Некоторые пары треугольников подобны. В силу свойств подобия известно, что все эти треугольники распадаются на несколько классов, в каждом из которых все треугольники подобны друг другу. К примеру, три треугольника со сторонами (6,6,10), (15,25,15), (35,21,21) все попарно подобны друг другу, то есть образуют один класс. Необходимо найти количество классов подобия, на которые распадаются данные n треугольников. Сложность алгоритма должна в среднем линейно зависеть от n (может еще зависеть от ограничений на стороны треугольника). Т.е. никаких сортировок длинных массивов в решении делать нельзя.

**Идея решения:**
Для каждого треугольника возьмём стороны a, b, c и отсортируем их по возрастанию. Разделим все стороны на их наибольший общий делитель (НОД), чтобы получить пропорции в минимальных целых числах. Используем множества (`Set`) для хранения всех уникальных нормализованных троек. Количество уникальных троек = количество классов подобия.

**Оценка сложности:**

* В среднем O(n) по числу треугольников, так как обработка каждой тройки занимает константное время (сортировка трёх элементов и вычисление НОД).
* Память O(n) для хранения нормализованных троек.

**Решение задачи (Swift):**

```swift
import Foundation

func gcd(_ a: Int, _ b: Int) -> Int {
    var a = a
    var b = b
    while b != 0 {
        let tmp = a % b
        a = b
        b = tmp
    }
    return a
}

let n = Int(readLine()!)!
var uniqueTriangles = Set<[Int]>()

for _ in 0..<n {
    let sides = readLine()!.split(separator: " ").map { Int($0)! }
    var sortedSides = sides.sorted()
    let g = gcd(gcd(sortedSides[0], sortedSides[1]), sortedSides[2])
    sortedSides = sortedSides.map { $0 / g }
    uniqueTriangles.insert(sortedSides)
}

print(uniqueTriangles.count)
```

### 4728. [Крош, Ежик и квадратичная игра](https://coderun.yandex.ru/problem/krosh-and-game)
**Условие задачи:**
Игра с кучкой камней: из n камней за ход можно убрать любое число, являющееся точным квадратом. Крош ходит первым. Проигрывает тот, кто не может сделать ход. Определить, кто выиграет при оптимальной игре для q независимых запросов.

---

**Идея решения:**
Используем динамическое программирование:

1. Создаём массив `dp[0...maxN]`, где `dp[i] = true`, если позиция с i камнями — выигрышная для текущего игрока.
2. Базовый случай: `dp[0] = false` (нет ходов).
3. Для каждого i от 1 до maxN: проверяем все возможные ходы — k² ≤ i. Если есть хотя бы один k², такой что `dp[i - k²] == false`, то `dp[i] = true` (т.е. можно сделать ход и оставить противника в проигрышной позиции).
4. После построения dp для всех запросов просто выводим `1`, если `dp[n] == true`, иначе `0`.

---

**Оценка сложности:**
O(maxN \* sqrt(maxN)) — для каждого n (до 10⁵) проверяем возможные квадраты ≤ n. Для данных ограничений это приемлемо.

---

**Решение задачи (Swift):**

```swift
import Foundation

let q = Int(readLine()!)!
var queries = [Int]()
var maxN = 0

for _ in 0..<q {
    let n = Int(readLine()!)!
    queries.append(n)
    maxN = max(maxN, n)
}

var dp = [Bool](repeating: false, count: maxN + 1)

for i in 1...maxN {
    var k = 1
    while k * k <= i {
        if !dp[i - k * k] {
            dp[i] = true
            break
        }
        k += 1
    }
}

for n in queries {
    print(dp[n] ? 1 : 0)
}
```

### 4729. [Крош и строка](https://coderun.yandex.ru/problem/krosh-and-string)
**Условие задачи:**
У Кроша есть строка из n строчных английских букв. За один ход Крош может выбрать два соседних равных символа и удалить их. Определите, может ли Крош удалить все символы из строки.

---

**Идея решения:**
Используем структуру данных стек: будем проходить по строке слева направо, добавляя символы в стек. Если текущий символ совпадает с верхом стека, удаляем верхний символ (т.е. удаляем пару). В конце, если стек пуст, значит можно удалить все символы, иначе — нет.

---

**Оценка сложности:**
O(n) — один проход по строке, каждая операция со стеком выполняется за O(1).

---

**Решение задачи (Swift):**

```swift
import Foundation

let n = Int(readLine()!)!
let s = Array(readLine()!)

var stack = [Character]()

for ch in s {
    if let last = stack.last, last == ch {
        stack.removeLast()
    } else {
        stack.append(ch)
    }
}

print(stack.isEmpty ? 1 : 0)
```

### 5202. [Юля, Никита и задачи](https://coderun.yandex.ru/problem/season-tasks)
**Условие задачи:**
Подготовка задач к сезону это долгий и кропотливый процесс. Юля знает, что уже готово A задач. Никита выяснил, что ещё B задач почти готовы и в ближайшее время будут добавлены в сезон. Помогите Юле и Никите узнать, сколько всего задач планируется в сезоне.

---

**Идея решения:**
Сложить два числа A и B для получения общего количества задач.

---

**Оценка сложности:**
O(1) — операция сложения двух чисел.

---

**Решение задачи (Swift):**

```swift
import Foundation

let input = readLine()!.split(separator: " ").map { UInt64($0)! }
let A = input[0]
let B = input[1]

let total = A + B
print(total)
```

### 5204. [Умножай и транспонируй!](https://coderun.yandex.ru/problem/matrix-operations)
**Условие задачи:**
Школьники из объединения КРОШ (Клуб Решателей Олимпиад Школьников) готовятся к участию в треке ML. Начать подготовку они решили с изучения линейной алгебры. Выяснилось, что существует две интересные операции над матрицами — умножение и транспонирование. Они составили много примеров и решают их на листике, однако им нужна помощь в проверке результатов. Напишите программу, которая по заданным матрицам A и B вычисляет:

$$
(A \times B)^T
$$

где A — матрица размером n×m, а B — матрица размером m×k.

---

**Идея решения:**

1. Считаем матрицы A и B.
2. Вычислим произведение матриц A×B.
3. Транспонируем полученную матрицу, меняя строки и столбцы местами.

---

**Оценка сложности:**

* Умножение матриц: O(n \* m \* k)
* Транспонирование: O(n \* k)
* Память: O(n \* k) для хранения результата

---

**Решение задачи (Swift):**

```swift
import Foundation

let nmks = readLine()!.split(separator: " ").map { Int($0)! }
let n = nmks[0]
let m = nmks[1]
let k = nmks[2]

// Чтение матрицы A
var A = [[Int]]()
for _ in 0..<n {
    let row = readLine()!.split(separator: " ").map { Int($0)! }
    A.append(row)
}

// Чтение матрицы B
var B = [[Int]]()
for _ in 0..<m {
    let row = readLine()!.split(separator: " ").map { Int($0)! }
    B.append(row)
}

// Умножение матриц A * B
var C = Array(repeating: Array(repeating: 0, count: k), count: n)
for i in 0..<n {
    for j in 0..<k {
        for t in 0..<m {
            C[i][j] += A[i][t] * B[t][j]
        }
    }
}

// Транспонирование результата (A*B)^T
for j in 0..<k {
    var row = [Int]()
    for i in 0..<n {
        row.append(C[i][j])
    }
    print(row.map { String($0) }.joined(separator: " "))
}
```

### 5205. [Ещё одна задача на теорию чисел](https://coderun.yandex.ru/problem/gcd-and-lcm)
**Условие задачи:**
Лене очень нравится теория чисел. В прошлый раз она просила участников сезона угадать функцию Эйлера. К сожалению, для некоторых пользователей эта задача оказалась слишком сложной, поэтому Лена придумала задачку попроще.

Вам даны 2 натуральных числа a и b. Необходимо посчитать НОД(a, b) и НОК(a, b).

Напомним, что:

* НОД(a, b) — наибольшее натуральное число, на которое числа a и b делятся без остатка.
* НОК(a, b) — наименьшее натуральное число, которое делится на числа a и b без остатка.

Формат ввода
Единственная входная строка содержит два числа — a, b (1 ≤ a, b ≤ 10⁹).

Формат вывода
Выведите 2 целых числа — НОД(a, b) и НОК(a, b).

---

**Идея решения:**

* Для нахождения НОД используем алгоритм Евклида.
* НОК можно вычислить через НОД по формуле:

$$
\text{НОК}(a, b) = \frac{a \cdot b}{\text{НОД}(a, b)}
$$

* Это обеспечивает корректность для больших чисел до 10⁹.

---

**Оценка сложности:**

* Время: O(log(min(a, b))) — алгоритм Евклида.
* Память: O(1)

---

**Решение задачи (Swift):**

```swift
import Foundation

func gcd(_ a: Int, _ b: Int) -> Int {
    var a = a
    var b = b
    while b != 0 {
        let r = a % b
        a = b
        b = r
    }
    return a
}

let input = readLine()!.split(separator: " ").map { Int($0)! }
let a = input[0]
let b = input[1]

let g = gcd(a, b)
let lcm = a / g * b  // чтобы избежать переполнения

print("\(g) \(lcm)")
```

### 5206. [Выставление тегов](https://coderun.yandex.ru/problem/calculate-tags)
**Условие задачи:**
Большинство задач сезона CodeRun имеют теги, помогающие пользователям выбрать подходящий алгоритм для решения. Известно, что для первой и второй задач каждого трека количество тегов равно 1 (t\[1]=t\[2]=1), а для всех следующих количество тегов вычисляется по следующему правилу:

t\[i] = t\[i−1] + t\[i−2],

где t\[i] — количество тегов задачи с номером i.

Было установлено, что на выставление одного тега требуется одна секунда. Посчитайте, сколько всего времени потребуется для выставления всех тегов.

Формат ввода
На вход подаётся одно целое число n (1 ≤ n ≤ 35) — количество задач в треке.

Формат вывода
Выведите одно целое число — сумму t\[i], время, необходимое для расстановки тегов для всех задач.

---

**Идея решения:**

* Последовательность t\[i] — это **числа Фибоначчи**, начиная с t\[1]=1, t\[2]=1.
* Необходимо найти сумму первых n чисел Фибоначчи.
* Можно посчитать итеративно, аккумулируя сумму.

---

**Оценка сложности:**

* Время: O(n)
* Память: O(1)

---

**Решение задачи (Swift):**

```swift
import Foundation

let n = Int(readLine()!)!

if n == 1 {
    print(1)
} else {
    var a = 1
    var b = 1
    var sum = 2
    if n == 2 {
        print(sum)
    } else {
        for _ in 3...n {
            let c = a + b
            sum += c
            a = b
            b = c
        }
        print(sum)
    }
}
```

### 5316. [Снежки](https://coderun.yandex.ru/problem/snowballs)
**Условие задачи:**
Новогодним утром Кодерун с другом лепили снежки и придумали игру. Изначально у игроков есть три кучки снежков. За свой ход игрок может взять из одной какой-то кучки один или два снежка, при условии, что в кучке есть необходимое количество снежков, и отложить их в сторону. Взятые снежки в дальнейшем не рассматриваются.

Проигрывает игрок, который не может сделать ход.

По заданным размерам трёх кучек определите, кто выиграет при оптимальной игре обоих игроков: тот, кто ходил первым, или тот, кто ходил вторым? Вам нужно ответить на t независимых запросов. Для каждого из них выведите 1, если при данных размерах кучек выигрывает первый игрок, и 0, если первый игрок проигрывает.

Формат ввода
В первой строке число 1≤t≤10 — количество запросов. В следующих t строках сами запросы. Каждый запрос описывается тремя числами 0≤a1,a2,a3≤10^9 — размерами кучек.

Формат вывода
Для каждого запроса выведите 1, если первый игрок выигрывает при данных размерах кучек, и 0 — иначе.

---

**Идея решения:**
Эта игра является частным случаем игры Ним с ограничением ходов (можно брать только 1 или 2 снежка).

* Для игры Ним можно использовать **значение Grundy (nimber)** для каждой кучки.
* Кучка размера n имеет Grundy-число g(n) = n % 3, потому что с ходами {1,2} последовательность Grundy повторяется циклически: 0→0, 1→1, 2→2, 3→0, 4→1,...
* Для трёх кучек, XOR всех Grundy-чисел: если результат ≠ 0, первый игрок выигрывает, иначе проигрывает.

---

**Оценка сложности:**

* Время: O(t), т.к. для каждого запроса считаем 3 остатка и XOR
* Память: O(1)

---

**Решение задачи (Swift):**

```swift
import Foundation

let t = Int(readLine()!)!

for _ in 0..<t {
    let piles = readLine()!.split(separator: " ").map { Int($0)! % 3 }
    let xor = piles[0] ^ piles[1] ^ piles[2]
    print(xor != 0 ? 1 : 0)
}
```

### 5317. [В город на ярмарку](https://coderun.yandex.ru/problem/new-year-fair)
**Условие задачи:**
Друзья пригласили Кодеруна к себе в город на новогоднюю ярмарку. Выйдя из поезда, он решил изучить схему местного транспорта. В городе есть n остановок и m маршрутов, каждый из которых обозначает, что существуют автобусы, которые ходят по заданному маршруту от одной остановки к другой и обратно, при этом не останавливаясь нигде на промежуточных пунктах.

Кодерун задался: интересно, какое максимально возможное количество маршрутов можно убрать? Но так, чтобы выполнялось следующее условие: для любой пары остановок a, b, если можно было добраться от a до b, используя один или несколько исходных маршрутов, то и после удаления маршрутов можно добраться от a до b.

Формат ввода
В первой строке количество остановок 1≤n≤100 и 0≤m≤n\*(n−1)/2. В следующих m строках содержатся описания маршрутов, каждая строка содержит два числа 1≤ai,bi≤n, ai≠bi, обозначающие наличие маршрута между остановками ai и bi. Все маршруты различны.

Формат вывода
Выведите максимально возможное количество маршрутов, которое можно удалить, так, что достижимость между каждой парой остановок останется прежней.

---

**Идея решения:**
Максимальное количество маршрутов, которое можно удалить, соответствует количеству «лишних» рёбер, т.е. рёбер, не входящих в минимальное остовное дерево графа.

1. Построим граф из заданных маршрутов.
2. Найдём количество компонент связности — для каждой компонент нужен хотя бы (size-1) маршрут для связности.
3. Минимальное количество маршрутов, чтобы сохранить связность всех компонент, равно сумме (size\_component-1) по всем компонентам, что эквивалентно числу рёбер в остовном лесу.
4. Максимальное число рёбер для удаления = m - минимальное количество рёбер для сохранения связности.

Так как граф неориентированный, минимальный остов можно найти обычным DFS или Union-Find.

---

**Оценка сложности:**

* Время: O(n + m) для обхода графа
* Память: O(n + m)

---

**Решение задачи (Swift):**

```swift
import Foundation

let firstLine = readLine()!.split(separator: " ").map { Int($0)! }
let n = firstLine[0]
let m = firstLine[1]

var adj = Array(repeating: [Int](), count: n)
for _ in 0..<m {
    let edge = readLine()!.split(separator: " ").map { Int($0)! - 1 }
    let u = edge[0]
    let v = edge[1]
    adj[u].append(v)
    adj[v].append(u)
}

var visited = Array(repeating: false, count: n)
var minEdges = 0

func dfs(_ u: Int) -> Int {
    visited[u] = true
    var size = 1
    for v in adj[u] {
        if !visited[v] {
            size += dfs(v)
        }
    }
    return size
}

for i in 0..<n {
    if !visited[i] {
        let componentSize = dfs(i)
        minEdges += componentSize - 1
    }
}

let maxRemovable = m - minEdges
print(maxRemovable)
```

### 5321. [Наряжаем ёлку](https://coderun.yandex.ru/problem/decorating-tree)
**Условие задачи:**
Новый год на носу, и Кодерун решил нарядить ёлку, но не простую, а геометрическую.

Он знает, что ёлка состоит из k слоёв, каждый из которых, в свою очередь, состоит из 2^(i−1) треугольных веточек. На каждую веточку он хочет повесить по шарику. Узнайте, сколько шариков понадобится Кодеруну для того, чтобы украсить всю ёлку.

Формат ввода
На вход программе подаётся одно натуральное число k (1≤k≤25) — количество слоёв ёлки.

Формат вывода
В качестве ответа выведите одно число — количество шариков, необходимых для украшения ёлки.

---

**Идея решения:**
Каждый слой i содержит 2^(i-1) веточек, на каждую из которых вешается один шарик. Сумма шариков по всем слоям — это сумма степени двойки от 2^0 до 2^(k-1). Это геометрическая прогрессия с суммой 2^k - 1.

---

**Оценка сложности:**

* Время: O(1)
* Память: O(1)

---

**Решение задачи (Swift):**

```swift
import Foundation

let k = Int(readLine()!)!
let totalBalls = (1 << k) - 1
print(totalBalls)
```















